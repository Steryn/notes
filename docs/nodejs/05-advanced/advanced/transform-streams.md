# ËΩ¨Êç¢ÊµÅ

## üéØ Â≠¶‰π†ÁõÆÊ†á

- Ê∑±ÂÖ•ÁêÜËß£ËΩ¨Êç¢ÊµÅÁöÑÂ∑•‰ΩúÂéüÁêÜÂíåÂ∫îÁî®Âú∫ÊôØ
- ÊéåÊè°Ëá™ÂÆö‰πâËΩ¨Êç¢ÊµÅÁöÑÂÆûÁé∞ÊñπÊ≥ï
- Â≠¶‰ºöÊï∞ÊçÆËΩ¨Êç¢„ÄÅËøáÊª§ÂíåËÅöÂêàÊäÄÊúØ
- ‰∫ÜËß£ÊµÅÊ∞¥Á∫øÂ§ÑÁêÜÂíåÊÄßËÉΩ‰ºòÂåñ

## üìö Ê†∏ÂøÉÊ¶ÇÂøµ

### ËΩ¨Êç¢ÊµÅÂü∫Á°Ä

```javascript
// ËΩ¨Êç¢ÊµÅÊ†∏ÂøÉÊ¶ÇÂøµ
const transformStreamConcepts = {
  definition: {
    description: 'ËΩ¨Êç¢ÊµÅÊòØÂêåÊó∂ÂèØËØªÂíåÂèØÂÜôÁöÑÊµÅ',
    inheritance: 'ÁªßÊâøËá™DuplexÊµÅ',
    purpose: 'ÂØπÈÄöËøáÊµÅÁöÑÊï∞ÊçÆËøõË°åËΩ¨Êç¢Â§ÑÁêÜ'
  },
  methods: {
    _transform: 'Â§ÑÁêÜÊØè‰∏™Êï∞ÊçÆÂùóÁöÑÊ†∏ÂøÉÊñπÊ≥ï',
    _flush: 'ÊµÅÁªìÊùüÂâçÁöÑÊúÄÁªàÂ§ÑÁêÜÊñπÊ≥ï',
    push: 'ÂêëÂèØËØªÁ´ØÊé®ÈÄÅËΩ¨Êç¢ÂêéÁöÑÊï∞ÊçÆ',
    callback: 'Â§ÑÁêÜÂÆåÊàêÂêéÁöÑÂõûË∞ÉÂáΩÊï∞'
  },
  patterns: {
    oneToOne: '‰∏ÄÂØπ‰∏ÄËΩ¨Êç¢ - ÊØè‰∏™ËæìÂÖ•‰∫ßÁîü‰∏Ä‰∏™ËæìÂá∫',
    oneToMany: '‰∏ÄÂØπÂ§öËΩ¨Êç¢ - ‰∏Ä‰∏™ËæìÂÖ•‰∫ßÁîüÂ§ö‰∏™ËæìÂá∫',
    manyToOne: 'Â§öÂØπ‰∏ÄËΩ¨Êç¢ - Â§ö‰∏™ËæìÂÖ•ÂêàÂπ∂‰∏∫‰∏Ä‰∏™ËæìÂá∫',
    filter: 'ËøáÊª§Ê®°Âºè - ÈÄâÊã©ÊÄßËæìÂá∫Êï∞ÊçÆ',
    aggregate: 'ËÅöÂêàÊ®°Âºè - Á¥ØÁßØÂ§ÑÁêÜÊï∞ÊçÆ'
  }
};

console.log('ËΩ¨Êç¢ÊµÅÊ¶ÇÂøµ:', transformStreamConcepts);
```

## üõ†Ô∏è Âü∫Á°ÄËΩ¨Êç¢ÊµÅÂÆûÁé∞

### Êï∞ÊçÆËΩ¨Êç¢ÊµÅ

```javascript
// basic-transform-streams.js
const { Transform } = require('stream');

// JSONËß£ÊûêËΩ¨Êç¢ÊµÅ
class JSONParseStream extends Transform {
  constructor(options = {}) {
    super({ 
      objectMode: true,
      ...options 
    });
    
    this.strict = options.strict !== false;
    this.skipErrors = options.skipErrors === true;
    this.errorCount = 0;
    this.successCount = 0;
  }

  _transform(chunk, encoding, callback) {
    try {
      const jsonString = chunk.toString().trim();
      
      if (!jsonString) {
        return callback();
      }
      
      const parsed = JSON.parse(jsonString);
      this.successCount++;
      
      this.push(parsed);
      callback();
      
    } catch (error) {
      this.errorCount++;
      
      if (this.skipErrors) {
        console.warn(`‚ö†Ô∏è JSONËß£ÊûêÈîôËØØ (Â∑≤Ë∑≥Ëøá): ${error.message}`);
        this.emit('parseError', { chunk, error });
        callback();
      } else if (this.strict) {
        callback(error);
      } else {
        // Èùû‰∏•Ê†ºÊ®°ÂºèÔºåÊé®ÈÄÅÂéüÂßãÊï∞ÊçÆ
        this.push({ 
          _parseError: error.message, 
          _rawData: chunk.toString() 
        });
        callback();
      }
    }
  }

  _flush(callback) {
    console.log(`üìä JSONËß£ÊûêÂÆåÊàê: ÊàêÂäü=${this.successCount}, ÈîôËØØ=${this.errorCount}`);
    callback();
  }
}

// Êï∞ÊçÆÈ™åËØÅËΩ¨Êç¢ÊµÅ
class ValidationStream extends Transform {
  constructor(schema, options = {}) {
    super({ 
      objectMode: true,
      ...options 
    });
    
    this.schema = schema;
    this.validCount = 0;
    this.invalidCount = 0;
    this.onInvalid = options.onInvalid || 'error'; // 'error', 'skip', 'mark'
  }

  _transform(chunk, encoding, callback) {
    try {
      const validation = this.validateData(chunk);
      
      if (validation.valid) {
        this.validCount++;
        this.push(chunk);
        callback();
      } else {
        this.invalidCount++;
        this.handleInvalidData(chunk, validation, callback);
      }
    } catch (error) {
      callback(error);
    }
  }

  validateData(data) {
    const errors = [];
    
    for (const [field, rules] of Object.entries(this.schema)) {
      const value = data[field];
      
      if (rules.required && (value === undefined || value === null)) {
        errors.push(`Â≠óÊÆµ ${field} ÊòØÂøÖÈúÄÁöÑ`);
        continue;
      }
      
      if (value !== undefined && rules.type) {
        const actualType = Array.isArray(value) ? 'array' : typeof value;
        if (actualType !== rules.type) {
          errors.push(`Â≠óÊÆµ ${field} Á±ªÂûãÈîôËØØ: ÊúüÊúõ ${rules.type}, ÂÆûÈôÖ ${actualType}`);
        }
      }
      
      if (value !== undefined && rules.validate) {
        try {
          if (!rules.validate(value)) {
            errors.push(`Â≠óÊÆµ ${field} È™åËØÅÂ§±Ë¥•`);
          }
        } catch (error) {
          errors.push(`Â≠óÊÆµ ${field} È™åËØÅÂáΩÊï∞ÈîôËØØ: ${error.message}`);
        }
      }
    }
    
    return {
      valid: errors.length === 0,
      errors: errors
    };
  }

  handleInvalidData(data, validation, callback) {
    switch (this.onInvalid) {
      case 'error':
        callback(new Error(`Êï∞ÊçÆÈ™åËØÅÂ§±Ë¥•: ${validation.errors.join(', ')}`));
        break;
        
      case 'skip':
        console.warn(`‚ö†Ô∏è Ë∑≥ËøáÊó†ÊïàÊï∞ÊçÆ: ${validation.errors.join(', ')}`);
        this.emit('invalidData', { data, errors: validation.errors });
        callback();
        break;
        
      case 'mark':
        const markedData = {
          ...data,
          _validation: {
            valid: false,
            errors: validation.errors
          }
        };
        this.push(markedData);
        callback();
        break;
        
      default:
        callback(new Error(`Êú™Áü•ÁöÑÊó†ÊïàÊï∞ÊçÆÂ§ÑÁêÜÊñπÂºè: ${this.onInvalid}`));
    }
  }

  _flush(callback) {
    const total = this.validCount + this.invalidCount;
    const successRate = total > 0 ? (this.validCount / total * 100).toFixed(2) : '0';
    
    console.log(`üìä Êï∞ÊçÆÈ™åËØÅÂÆåÊàê: ÊúâÊïà=${this.validCount}, Êó†Êïà=${this.invalidCount}, ÊàêÂäüÁéá=${successRate}%`);
    callback();
  }
}

// Êï∞ÊçÆÊ†ºÂºèÂåñËΩ¨Êç¢ÊµÅ
class FormatStream extends Transform {
  constructor(formatter, options = {}) {
    super({ 
      objectMode: true,
      ...options 
    });
    
    this.formatter = formatter;
    this.formatCount = 0;
  }

  _transform(chunk, encoding, callback) {
    try {
      const formatted = this.formatter(chunk);
      this.formatCount++;
      
      if (formatted !== undefined && formatted !== null) {
        this.push(formatted);
      }
      
      callback();
    } catch (error) {
      callback(error);
    }
  }

  _flush(callback) {
    console.log(`üìä Êï∞ÊçÆÊ†ºÂºèÂåñÂÆåÊàê: ${this.formatCount} È°π`);
    callback();
  }
}

// CSVËΩ¨Êç¢ÊµÅ
class CSVTransformStream extends Transform {
  constructor(options = {}) {
    super({
      objectMode: true,
      ...options
    });
    
    this.headers = options.headers || null;
    this.delimiter = options.delimiter || ',';
    this.quote = options.quote || '"';
    this.escape = options.escape || '"';
    this.skipHeader = options.skipHeader === true;
    this.autoDetectHeaders = options.autoDetectHeaders !== false;
    
    this.isFirstRow = true;
    this.rowCount = 0;
  }

  _transform(chunk, encoding, callback) {
    try {
      const line = chunk.toString().trim();
      
      if (!line) {
        return callback();
      }
      
      const fields = this.parseCSVLine(line);
      
      if (this.isFirstRow) {
        this.isFirstRow = false;
        
        if (this.autoDetectHeaders && !this.headers) {
          this.headers = fields;
          
          if (this.skipHeader) {
            return callback();
          }
        }
      }
      
      let result;
      
      if (this.headers) {
        result = {};
        fields.forEach((field, index) => {
          if (this.headers[index]) {
            result[this.headers[index]] = field;
          }
        });
      } else {
        result = fields;
      }
      
      this.rowCount++;
      this.push(result);
      callback();
      
    } catch (error) {
      callback(error);
    }
  }

  parseCSVLine(line) {
    const fields = [];
    let currentField = '';
    let inQuotes = false;
    let i = 0;
    
    while (i < line.length) {
      const char = line[i];
      const nextChar = line[i + 1];
      
      if (char === this.quote) {
        if (inQuotes && nextChar === this.quote) {
          // ËΩ¨‰πâÂºïÂè∑
          currentField += this.quote;
          i += 2;
        } else {
          // ÂºÄÂßãÊàñÁªìÊùüÂºïÂè∑
          inQuotes = !inQuotes;
          i++;
        }
      } else if (char === this.delimiter && !inQuotes) {
        // Â≠óÊÆµÂàÜÈöîÁ¨¶
        fields.push(currentField);
        currentField = '';
        i++;
      } else {
        currentField += char;
        i++;
      }
    }
    
    fields.push(currentField);
    return fields;
  }

  _flush(callback) {
    console.log(`üìä CSVËΩ¨Êç¢ÂÆåÊàê: ${this.rowCount} Ë°å`);
    callback();
  }
}

// ‰ΩøÁî®Á§∫‰æã
async function demonstrateBasicTransforms() {
  console.log('üîÑ Âü∫Á°ÄËΩ¨Êç¢ÊµÅÊºîÁ§∫...\n');

  // 1. JSONËß£ÊûêÊµÅ
  console.log('1. JSONËß£ÊûêËΩ¨Êç¢:');
  const { Readable } = require('stream');
  
  const jsonData = [
    '{"name": "Alice", "age": 30}',
    '{"name": "Bob", "age": 25}',
    'invalid json',
    '{"name": "Charlie", "age": 35}'
  ];

  const jsonSource = Readable.from(jsonData);
  const jsonParser = new JSONParseStream({ skipErrors: true });

  jsonSource.pipe(jsonParser);

  jsonParser.on('data', (data) => {
    console.log('  Ëß£ÊûêÁªìÊûú:', data);
  });

  await new Promise(resolve => jsonParser.on('end', resolve));

  // 2. Êï∞ÊçÆÈ™åËØÅÊµÅ
  console.log('\n2. Êï∞ÊçÆÈ™åËØÅËΩ¨Êç¢:');
  const schema = {
    name: { required: true, type: 'string' },
    age: { required: true, type: 'number', validate: (age) => age > 0 && age < 150 },
    email: { type: 'string', validate: (email) => email.includes('@') }
  };

  const validationData = [
    { name: 'Alice', age: 30, email: 'alice@example.com' },
    { name: 'Bob', age: -5 }, // Êó†ÊïàÂπ¥ÈæÑ
    { age: 25 }, // Áº∫Â∞ëname
    { name: 'Charlie', age: 35, email: 'invalid-email' }
  ];

  const validationSource = Readable.from(validationData);
  const validator = new ValidationStream(schema, { onInvalid: 'mark' });

  validationSource.pipe(validator);

  validator.on('data', (data) => {
    console.log('  È™åËØÅÁªìÊûú:', data);
  });

  await new Promise(resolve => validator.on('end', resolve));

  // 3. Êï∞ÊçÆÊ†ºÂºèÂåñÊµÅ
  console.log('\n3. Êï∞ÊçÆÊ†ºÂºèÂåñËΩ¨Êç¢:');
  const formatter = (data) => {
    if (data.name && data.age) {
      return `${data.name} (${data.age}Â≤Å)`;
    }
    return null;
  };

  const formatData = [
    { name: 'Alice', age: 30 },
    { name: 'Bob', age: 25 },
    { invalid: 'data' }
  ];

  const formatSource = Readable.from(formatData);
  const formatStream = new FormatStream(formatter);

  formatSource.pipe(formatStream);

  formatStream.on('data', (data) => {
    console.log('  Ê†ºÂºèÂåñÁªìÊûú:', data);
  });

  await new Promise(resolve => formatStream.on('end', resolve));
}

module.exports = {
  JSONParseStream,
  ValidationStream,
  FormatStream,
  CSVTransformStream,
  demonstrateBasicTransforms
};
```

### È´òÁ∫ßËΩ¨Êç¢ÊµÅÂÆûÁé∞

```javascript
// advanced-transform-streams.js
const { Transform } = require('stream');

// ËÅöÂêàËΩ¨Êç¢ÊµÅ
class AggregateStream extends Transform {
  constructor(options = {}) {
    super({ 
      objectMode: true,
      ...options 
    });
    
    this.windowSize = options.windowSize || 100;
    this.groupBy = options.groupBy || null;
    this.aggregators = options.aggregators || {};
    this.emitInterval = options.emitInterval || null;
    
    this.buffer = [];
    this.groups = new Map();
    this.processedCount = 0;
    
    if (this.emitInterval) {
      this.intervalTimer = setInterval(() => {
        this.emitAggregates();
      }, this.emitInterval);
    }
  }

  _transform(chunk, encoding, callback) {
    this.processedCount++;
    
    if (this.groupBy) {
      this.processGroupedData(chunk);
    } else {
      this.buffer.push(chunk);
      
      if (this.buffer.length >= this.windowSize) {
        this.processBuffer();
      }
    }
    
    callback();
  }

  processGroupedData(chunk) {
    const groupKey = typeof this.groupBy === 'function' 
      ? this.groupBy(chunk) 
      : chunk[this.groupBy];
    
    if (!this.groups.has(groupKey)) {
      this.groups.set(groupKey, []);
    }
    
    this.groups.get(groupKey).push(chunk);
    
    // Ê£ÄÊü•ÁªÑÂ§ßÂ∞è
    if (this.groups.get(groupKey).length >= this.windowSize) {
      this.processGroup(groupKey);
    }
  }

  processGroup(groupKey) {
    const groupData = this.groups.get(groupKey);
    const aggregate = this.calculateAggregates(groupData);
    
    this.push({
      group: groupKey,
      count: groupData.length,
      ...aggregate,
      timestamp: Date.now()
    });
    
    this.groups.set(groupKey, []); // Ê∏ÖÁ©∫ÁªÑ
  }

  processBuffer() {
    const aggregate = this.calculateAggregates(this.buffer);
    
    this.push({
      count: this.buffer.length,
      ...aggregate,
      timestamp: Date.now()
    });
    
    this.buffer = [];
  }

  calculateAggregates(data) {
    const result = {};
    
    for (const [name, aggregator] of Object.entries(this.aggregators)) {
      try {
        result[name] = aggregator(data);
      } catch (error) {
        console.error(`ËÅöÂêàÂô® ${name} ÊâßË°åÂ§±Ë¥•:`, error);
        result[name] = null;
      }
    }
    
    return result;
  }

  emitAggregates() {
    // ÂèëÂ∞ÑÊâÄÊúâÂæÖÂ§ÑÁêÜÁöÑËÅöÂêà
    if (this.buffer.length > 0) {
      this.processBuffer();
    }
    
    for (const groupKey of this.groups.keys()) {
      if (this.groups.get(groupKey).length > 0) {
        this.processGroup(groupKey);
      }
    }
  }

  _flush(callback) {
    if (this.intervalTimer) {
      clearInterval(this.intervalTimer);
    }
    
    // Â§ÑÁêÜÂâ©‰ΩôÊï∞ÊçÆ
    this.emitAggregates();
    
    console.log(`üìä ËÅöÂêàËΩ¨Êç¢ÂÆåÊàê: Â§ÑÁêÜ ${this.processedCount} È°π`);
    callback();
  }
}

// ÊâπÈáèÂ§ÑÁêÜËΩ¨Êç¢ÊµÅ
class BatchTransformStream extends Transform {
  constructor(processor, options = {}) {
    super({ 
      objectMode: true,
      ...options 
    });
    
    this.processor = processor;
    this.batchSize = options.batchSize || 10;
    this.batchTimeout = options.batchTimeout || 1000;
    this.parallel = options.parallel || false;
    this.maxConcurrency = options.maxConcurrency || 5;
    
    this.batch = [];
    this.batchTimer = null;
    this.activeBatches = 0;
    this.processedBatches = 0;
  }

  _transform(chunk, encoding, callback) {
    this.batch.push(chunk);
    
    if (this.batch.length >= this.batchSize) {
      this.processBatch();
    } else if (!this.batchTimer) {
      this.batchTimer = setTimeout(() => {
        this.processBatch();
      }, this.batchTimeout);
    }
    
    callback();
  }

  async processBatch() {
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
      this.batchTimer = null;
    }
    
    if (this.batch.length === 0) {
      return;
    }
    
    const currentBatch = this.batch.splice(0);
    
    if (this.parallel) {
      this.processParallelBatch(currentBatch);
    } else {
      await this.processSequentialBatch(currentBatch);
    }
  }

  async processParallelBatch(batch) {
    if (this.activeBatches >= this.maxConcurrency) {
      // Á≠âÂæÖÊúâÁ©∫Èó≤ÊßΩ‰Ωç
      await new Promise(resolve => {
        const checkSlot = () => {
          if (this.activeBatches < this.maxConcurrency) {
            resolve();
          } else {
            setTimeout(checkSlot, 10);
          }
        };
        checkSlot();
      });
    }
    
    this.activeBatches++;
    
    try {
      const results = await this.processor(batch);
      this.emitResults(results);
    } catch (error) {
      console.error('Âπ∂Ë°åÊâπÂ§ÑÁêÜÂ§±Ë¥•:', error);
      this.emit('error', error);
    } finally {
      this.activeBatches--;
      this.processedBatches++;
    }
  }

  async processSequentialBatch(batch) {
    try {
      const results = await this.processor(batch);
      this.emitResults(results);
      this.processedBatches++;
    } catch (error) {
      console.error('È°∫Â∫èÊâπÂ§ÑÁêÜÂ§±Ë¥•:', error);
      this.emit('error', error);
    }
  }

  emitResults(results) {
    if (Array.isArray(results)) {
      results.forEach(result => this.push(result));
    } else if (results !== undefined) {
      this.push(results);
    }
  }

  async _flush(callback) {
    // Â§ÑÁêÜÂâ©‰ΩôÊâπÊ¨°
    await this.processBatch();
    
    // Á≠âÂæÖÊâÄÊúâÂπ∂Ë°åÊâπÊ¨°ÂÆåÊàê
    while (this.activeBatches > 0) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }
    
    console.log(`üìä ÊâπÈáèÂ§ÑÁêÜÂÆåÊàê: ${this.processedBatches} ‰∏™ÊâπÊ¨°`);
    callback();
  }
}

// ÊµÅÊ∞¥Á∫øËΩ¨Êç¢ÊµÅ
class PipelineTransformStream extends Transform {
  constructor(transformers, options = {}) {
    super({ 
      objectMode: true,
      ...options 
    });
    
    this.transformers = transformers;
    this.processedCount = 0;
    this.errorCount = 0;
    this.continueOnError = options.continueOnError === true;
  }

  _transform(chunk, encoding, callback) {
    this.processChunk(chunk, 0, callback);
  }

  async processChunk(data, transformerIndex, callback) {
    if (transformerIndex >= this.transformers.length) {
      // ÊâÄÊúâËΩ¨Êç¢Âô®Â§ÑÁêÜÂÆåÊàê
      this.processedCount++;
      this.push(data);
      return callback();
    }
    
    try {
      const transformer = this.transformers[transformerIndex];
      const result = await this.applyTransformer(transformer, data);
      
      if (result !== undefined && result !== null) {
        this.processChunk(result, transformerIndex + 1, callback);
      } else {
        // Êï∞ÊçÆË¢´ËøáÊª§Êéâ
        callback();
      }
    } catch (error) {
      this.errorCount++;
      
      if (this.continueOnError) {
        console.warn(`‚ö†Ô∏è ËΩ¨Êç¢Âô® ${transformerIndex} Â§ÑÁêÜÂ§±Ë¥•:`, error.message);
        this.emit('transformError', { data, transformerIndex, error });
        callback();
      } else {
        callback(error);
      }
    }
  }

  async applyTransformer(transformer, data) {
    if (typeof transformer === 'function') {
      return transformer(data);
    } else if (transformer && typeof transformer.transform === 'function') {
      return transformer.transform(data);
    } else {
      throw new Error('Êó†ÊïàÁöÑËΩ¨Êç¢Âô®');
    }
  }

  _flush(callback) {
    const successRate = this.processedCount + this.errorCount > 0 
      ? (this.processedCount / (this.processedCount + this.errorCount) * 100).toFixed(2)
      : '0';
    
    console.log(`üìä ÊµÅÊ∞¥Á∫øÂ§ÑÁêÜÂÆåÊàê: ÊàêÂäü=${this.processedCount}, ÈîôËØØ=${this.errorCount}, ÊàêÂäüÁéá=${successRate}%`);
    callback();
  }
}

// ÁºìÂ≠òËΩ¨Êç¢ÊµÅ
class CachedTransformStream extends Transform {
  constructor(transformer, options = {}) {
    super({ 
      objectMode: true,
      ...options 
    });
    
    this.transformer = transformer;
    this.cache = new Map();
    this.maxCacheSize = options.maxCacheSize || 1000;
    this.ttl = options.ttl || 300000; // 5ÂàÜÈíü
    this.keyGenerator = options.keyGenerator || JSON.stringify;
    
    this.cacheHits = 0;
    this.cacheMisses = 0;
    
    // ÂÆöÊúüÊ∏ÖÁêÜËøáÊúüÁºìÂ≠ò
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredCache();
    }, 60000); // ÊØèÂàÜÈíüÊ∏ÖÁêÜ‰∏ÄÊ¨°
  }

  _transform(chunk, encoding, callback) {
    const cacheKey = this.keyGenerator(chunk);
    const cached = this.cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      // ÁºìÂ≠òÂëΩ‰∏≠
      this.cacheHits++;
      this.push(cached.result);
      callback();
    } else {
      // ÁºìÂ≠òÊú™ÂëΩ‰∏≠ÔºåÊâßË°åËΩ¨Êç¢
      this.cacheMisses++;
      this.executeTransform(chunk, cacheKey, callback);
    }
  }

  async executeTransform(chunk, cacheKey, callback) {
    try {
      const result = await this.transformer(chunk);
      
      // Â≠òÂÇ®Âà∞ÁºìÂ≠ò
      this.storeInCache(cacheKey, result);
      
      if (result !== undefined && result !== null) {
        this.push(result);
      }
      
      callback();
    } catch (error) {
      callback(error);
    }
  }

  storeInCache(key, result) {
    // LRUÊ∏ÖÁêÜ
    if (this.cache.size >= this.maxCacheSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, {
      result: result,
      timestamp: Date.now()
    });
  }

  cleanupExpiredCache() {
    const now = Date.now();
    const expiredKeys = [];
    
    for (const [key, value] of this.cache) {
      if (now - value.timestamp > this.ttl) {
        expiredKeys.push(key);
      }
    }
    
    expiredKeys.forEach(key => this.cache.delete(key));
    
    if (expiredKeys.length > 0) {
      console.log(`üßπ Ê∏ÖÁêÜËøáÊúüÁºìÂ≠ò: ${expiredKeys.length} È°π`);
    }
  }

  _destroy(error, callback) {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
    callback(error);
  }

  _flush(callback) {
    const totalRequests = this.cacheHits + this.cacheMisses;
    const hitRate = totalRequests > 0 ? (this.cacheHits / totalRequests * 100).toFixed(2) : '0';
    
    console.log(`üìä ÁºìÂ≠òËΩ¨Êç¢ÂÆåÊàê: ÂëΩ‰∏≠=${this.cacheHits}, Êú™ÂëΩ‰∏≠=${this.cacheMisses}, ÂëΩ‰∏≠Áéá=${hitRate}%`);
    callback();
  }

  getCacheStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxCacheSize,
      hits: this.cacheHits,
      misses: this.cacheMisses,
      hitRate: this.cacheHits + this.cacheMisses > 0 
        ? (this.cacheHits / (this.cacheHits + this.cacheMisses) * 100).toFixed(2) + '%'
        : '0%'
    };
  }
}

module.exports = {
  AggregateStream,
  BatchTransformStream,
  PipelineTransformStream,
  CachedTransformStream
};
```

## üîß ÂÆûÁî®ËΩ¨Êç¢ÊµÅÂ∑•ÂÖ∑

### ÈÄöÁî®ËΩ¨Êç¢Â∑•ÂÖ∑ÈõÜ

```javascript
// transform-utilities.js
const { Transform, pipeline } = require('stream');

// ËΩ¨Êç¢ÊµÅÂ∑•ÂéÇ
class TransformFactory {
  // ÂàõÂª∫Êò†Â∞ÑËΩ¨Êç¢ÊµÅ
  static map(mapper) {
    return new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        try {
          const result = mapper(chunk);
          if (result !== undefined) {
            this.push(result);
          }
          callback();
        } catch (error) {
          callback(error);
        }
      }
    });
  }

  // ÂàõÂª∫ËøáÊª§ËΩ¨Êç¢ÊµÅ
  static filter(predicate) {
    return new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        try {
          if (predicate(chunk)) {
            this.push(chunk);
          }
          callback();
        } catch (error) {
          callback(error);
        }
      }
    });
  }

  // ÂàõÂª∫ÂΩíÁ∫¶ËΩ¨Êç¢ÊµÅ
  static reduce(reducer, initialValue) {
    let accumulator = initialValue;
    
    return new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        try {
          accumulator = reducer(accumulator, chunk);
          callback();
        } catch (error) {
          callback(error);
        }
      },
      flush(callback) {
        this.push(accumulator);
        callback();
      }
    });
  }

  // ÂàõÂª∫ÂéªÈáçËΩ¨Êç¢ÊµÅ
  static unique(keySelector) {
    const seen = new Set();
    
    return new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        try {
          const key = keySelector ? keySelector(chunk) : chunk;
          
          if (!seen.has(key)) {
            seen.add(key);
            this.push(chunk);
          }
          
          callback();
        } catch (error) {
          callback(error);
        }
      }
    });
  }

  // ÂàõÂª∫ÊéíÂ∫èËΩ¨Êç¢ÊµÅ
  static sort(compareFn) {
    const items = [];
    
    return new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        items.push(chunk);
        callback();
      },
      flush(callback) {
        try {
          const sorted = items.sort(compareFn);
          sorted.forEach(item => this.push(item));
          callback();
        } catch (error) {
          callback(error);
        }
      }
    });
  }

  // ÂàõÂª∫ÈôêÂà∂ËΩ¨Êç¢ÊµÅ
  static take(count) {
    let taken = 0;
    
    return new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        if (taken < count) {
          this.push(chunk);
          taken++;
        }
        
        if (taken >= count) {
          this.push(null); // ÁªìÊùüÊµÅ
        }
        
        callback();
      }
    });
  }

  // ÂàõÂª∫Ë∑≥ËøáËΩ¨Êç¢ÊµÅ
  static skip(count) {
    let skipped = 0;
    
    return new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        if (skipped < count) {
          skipped++;
        } else {
          this.push(chunk);
        }
        callback();
      }
    });
  }
}

// ÊµÅÊ∞¥Á∫øÊûÑÂª∫Âô®
class StreamPipelineBuilder {
  constructor() {
    this.transforms = [];
  }

  map(mapper) {
    this.transforms.push(TransformFactory.map(mapper));
    return this;
  }

  filter(predicate) {
    this.transforms.push(TransformFactory.filter(predicate));
    return this;
  }

  unique(keySelector) {
    this.transforms.push(TransformFactory.unique(keySelector));
    return this;
  }

  sort(compareFn) {
    this.transforms.push(TransformFactory.sort(compareFn));
    return this;
  }

  take(count) {
    this.transforms.push(TransformFactory.take(count));
    return this;
  }

  skip(count) {
    this.transforms.push(TransformFactory.skip(count));
    return this;
  }

  custom(transform) {
    this.transforms.push(transform);
    return this;
  }

  build() {
    return this.transforms;
  }

  // ÊâßË°åÊµÅÊ∞¥Á∫ø
  async execute(source, destination) {
    return new Promise((resolve, reject) => {
      const streams = [source, ...this.transforms];
      
      if (destination) {
        streams.push(destination);
      }

      pipeline(...streams, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }
}

// ‰ΩøÁî®Á§∫‰æã
async function demonstrateTransformUtilities() {
  console.log('üîß ËΩ¨Êç¢ÊµÅÂ∑•ÂÖ∑ÊºîÁ§∫...\n');

  const { Readable } = require('stream');

  // Á§∫‰æãÊï∞ÊçÆ
  const data = [
    { id: 1, name: 'Alice', age: 30, city: 'New York' },
    { id: 2, name: 'Bob', age: 25, city: 'London' },
    { id: 3, name: 'Alice', age: 35, city: 'Paris' },
    { id: 4, name: 'Charlie', age: 40, city: 'Tokyo' },
    { id: 5, name: 'David', age: 28, city: 'New York' },
    { id: 6, name: 'Eve', age: 32, city: 'London' }
  ];

  const source = Readable.from(data);

  // ÊûÑÂª∫ÊµÅÊ∞¥Á∫ø
  const pipeline = new StreamPipelineBuilder()
    .filter(person => person.age > 25)  // ËøáÊª§Âπ¥ÈæÑÂ§ß‰∫é25ÁöÑ
    .map(person => ({                   // ËΩ¨Êç¢Êï∞ÊçÆÊ†ºÂºè
      ...person,
      ageGroup: person.age < 30 ? 'young' : 'adult',
      displayName: `${person.name} (${person.age})`
    }))
    .unique(person => person.name)      // ÊåâÂßìÂêçÂéªÈáç
    .sort((a, b) => b.age - a.age)      // ÊåâÂπ¥ÈæÑÈôçÂ∫èÊéíÂ∫è
    .take(3);                           // Âè™ÂèñÂâç3‰∏™

  // Êî∂ÈõÜÁªìÊûú
  const results = [];
  const collector = new Transform({
    objectMode: true,
    transform(chunk, encoding, callback) {
      results.push(chunk);
      callback();
    }
  });

  pipeline.custom(collector);

  // ÊâßË°åÊµÅÊ∞¥Á∫ø
  await pipeline.execute(source);

  console.log('ÊµÅÊ∞¥Á∫øÂ§ÑÁêÜÁªìÊûú:');
  results.forEach((result, index) => {
    console.log(`${index + 1}. ${JSON.stringify(result)}`);
  });
}

module.exports = {
  TransformFactory,
  StreamPipelineBuilder,
  demonstrateTransformUtilities
};
```

ËΩ¨Êç¢ÊµÅÊòØNode.jsÊµÅÂ§ÑÁêÜ‰∏≠ÊúÄÁÅµÊ¥ªÂíåÂº∫Â§ßÁöÑÁªÑ‰ª∂ÔºåÈÄöËøáÂêàÁêÜÁöÑËÆæËÆ°ÂíåÁªÑÂêàÂèØ‰ª•ÊûÑÂª∫Âá∫È´òÊïàÁöÑÊï∞ÊçÆÂ§ÑÁêÜÊµÅÊ∞¥Á∫øÔºÅ
