# Êï∞ÊçÆÂ∫ìÂõûÊªöÊú∫Âà∂

## üéØ Â≠¶‰π†ÁõÆÊ†á

- ÊéåÊè°Êï∞ÊçÆÂ∫ìÂõûÊªöÊú∫Âà∂ÁöÑÂéüÁêÜ
- Â≠¶‰ºöËÆæËÆ°ÂÆâÂÖ®ÁöÑÂõûÊªöÁ≠ñÁï•
- ÁêÜËß£‰∏çÂêåÂú∫ÊôØ‰∏ãÁöÑÂõûÊªöÊñπÊ°à
- ÊéåÊè°Ëá™Âä®ÂåñÂõûÊªöÂ∑•ÂÖ∑ÁöÑÂÆûÁé∞

## üìö Ê†∏ÂøÉÊ¶ÇÂøµ

### ‰ªÄ‰πàÊòØÊï∞ÊçÆÂ∫ìÂõûÊªö

Êï∞ÊçÆÂ∫ìÂõûÊªöÊòØÂ∞ÜÊï∞ÊçÆÂ∫ìÁä∂ÊÄÅÊÅ¢Â§çÂà∞‰πãÂâçÊüê‰∏™ÁâπÂÆöÊó∂Èó¥ÁÇπÁöÑËøáÁ®ãÔºåÁî®‰∫éÂ§ÑÁêÜÈîôËØØ„ÄÅÂ§±Ë¥•ÁöÑÈÉ®ÁΩ≤ÊàñÊï∞ÊçÆÊçüÂùèÁ≠âÊÉÖÂÜµ„ÄÇ

```javascript
// ÂõûÊªöÊú∫Âà∂Âü∫Êú¨Ê¶ÇÂøµ
const rollbackConcepts = {
  types: [
    'transaction_rollback',    // ‰∫ãÂä°ÂõûÊªö
    'migration_rollback',      // ËøÅÁßªÂõûÊªö
    'point_in_time_recovery', // Êó∂Èó¥ÁÇπÊÅ¢Â§ç
    'snapshot_restore'        // Âø´ÁÖßÊÅ¢Â§ç
  ],
  triggers: [
    'deployment_failure',     // ÈÉ®ÁΩ≤Â§±Ë¥•
    'data_corruption',        // Êï∞ÊçÆÊçüÂùè
    'performance_issues',     // ÊÄßËÉΩÈóÆÈ¢ò
    'business_requirements'   // ‰∏öÂä°ÈúÄÊ±Ç
  ]
};
```

### ÂõûÊªöÁöÑÈáçË¶ÅÊÄß

1. **È£éÈô©ÊéßÂà∂**ÔºöÂø´ÈÄüÊÅ¢Â§çÁ≥ªÁªüÊ≠£Â∏∏Áä∂ÊÄÅ
2. **Êï∞ÊçÆ‰øùÊä§**ÔºöÈò≤Ê≠¢Êï∞ÊçÆ‰∏¢Â§±ÊàñÊçüÂùè
3. **‰∏öÂä°ËøûÁª≠ÊÄß**ÔºöÊúÄÂ∞èÂåñÁ≥ªÁªüÂÅúÊú∫Êó∂Èó¥
4. **ÂºÄÂèëÊïàÁéá**ÔºöÊîØÊåÅÂø´ÈÄüËø≠‰ª£ÂíåËØïÈ™å

## üõ†Ô∏è ÂõûÊªöÁ≠ñÁï•ËÆæËÆ°

### 1. ‰∫ãÂä°Á∫ßÂõûÊªö

```javascript
// transaction-rollback.js
const { Sequelize, DataTypes } = require('sequelize');

class TransactionRollback {
  constructor(sequelize) {
    this.sequelize = sequelize;
  }

  async safeOperation(operations) {
    const transaction = await this.sequelize.transaction({
      isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE
    });

    try {
      console.log('üöÄ Starting transaction...');
      
      // ÊâßË°åÊâÄÊúâÊìç‰Ωú
      const results = [];
      for (const operation of operations) {
        const result = await operation(transaction);
        results.push(result);
        
        console.log(`‚úÖ Operation completed: ${operation.name}`);
      }

      // Êèê‰∫§‰∫ãÂä°
      await transaction.commit();
      console.log('‚úÖ Transaction committed successfully');
      
      return results;
      
    } catch (error) {
      console.error('‚ùå Transaction failed, rolling back...', error.message);
      
      try {
        await transaction.rollback();
        console.log('‚Ü©Ô∏è  Transaction rolled back successfully');
      } catch (rollbackError) {
        console.error('üí• Rollback failed:', rollbackError.message);
        throw rollbackError;
      }
      
      throw error;
    }
  }

  async batchUpdate(tableName, updates) {
    return this.safeOperation([
      async (transaction) => {
        // Â§á‰ªΩÂéüÂßãÊï∞ÊçÆ
        const originalData = await this.sequelize.query(
          `SELECT * FROM ${tableName} WHERE id IN (:ids)`,
          {
            replacements: { ids: updates.map(u => u.id) },
            type: Sequelize.QueryTypes.SELECT,
            transaction
          }
        );

        // ÊâßË°åÊõ¥Êñ∞
        for (const update of updates) {
          await this.sequelize.query(
            `UPDATE ${tableName} SET ${Object.keys(update.data).map(key => `${key} = :${key}`).join(', ')} WHERE id = :id`,
            {
              replacements: { ...update.data, id: update.id },
              transaction
            }
          );
        }

        return { originalData, updatedCount: updates.length };
      }
    ]);
  }
}

// ‰ΩøÁî®Á§∫‰æã
const rollbackManager = new TransactionRollback(sequelize);

async function updateUserProfiles() {
  try {
    const updates = [
      { id: 1, data: { email: 'new1@example.com', status: 'active' } },
      { id: 2, data: { email: 'new2@example.com', status: 'inactive' } }
    ];

    const result = await rollbackManager.batchUpdate('users', updates);
    console.log('Batch update completed:', result);
    
  } catch (error) {
    console.error('Batch update failed:', error.message);
  }
}
```

### 2. ËøÅÁßªÂõûÊªö

```javascript
// migration-rollback.js
const fs = require('fs').promises;
const path = require('path');

class MigrationRollback {
  constructor(migrationPath, sequelize) {
    this.migrationPath = migrationPath;
    this.sequelize = sequelize;
    this.rollbackHistory = [];
  }

  async getMigrationFiles() {
    const files = await fs.readdir(this.migrationPath);
    return files
      .filter(file => file.endsWith('.js'))
      .sort()
      .reverse(); // ÊåâÊó∂Èó¥ÂÄíÂ∫è
  }

  async rollbackMigration(steps = 1) {
    console.log(`üîÑ Rolling back ${steps} migration(s)...`);
    
    const migrationFiles = await this.getMigrationFiles();
    const executedMigrations = await this.getExecutedMigrations();
    
    // ÊâæÂà∞ÈúÄË¶ÅÂõûÊªöÁöÑËøÅÁßª
    const migrationsToRollback = executedMigrations
      .slice(0, steps)
      .reverse();

    for (const migration of migrationsToRollback) {
      await this.rollbackSingleMigration(migration);
    }

    console.log(`‚úÖ Successfully rolled back ${steps} migration(s)`);
  }

  async rollbackSingleMigration(migrationName) {
    const transaction = await this.sequelize.transaction();
    
    try {
      console.log(`‚Ü©Ô∏è  Rolling back: ${migrationName}`);
      
      // Âä†ËΩΩËøÅÁßªÊñá‰ª∂
      const migrationFile = path.join(this.migrationPath, migrationName);
      const migration = require(migrationFile);
      
      // ÂàõÂª∫ÂõûÊªöÁÇπ
      const rollbackPoint = await this.createRollbackPoint(migrationName);
      
      // ÊâßË°ådownÊñπÊ≥ï
      if (migration.down) {
        await migration.down(this.sequelize.getQueryInterface(), this.sequelize.constructor, { transaction });
      } else {
        throw new Error(`No down method found for migration: ${migrationName}`);
      }

      // Êõ¥Êñ∞ËøÅÁßªÁä∂ÊÄÅ
      await this.updateMigrationStatus(migrationName, 'down', transaction);
      
      await transaction.commit();
      
      this.rollbackHistory.push({
        migration: migrationName,
        rolledBackAt: new Date().toISOString(),
        rollbackPoint
      });
      
      console.log(`‚úÖ Successfully rolled back: ${migrationName}`);
      
    } catch (error) {
      await transaction.rollback();
      console.error(`‚ùå Failed to rollback ${migrationName}:`, error.message);
      throw error;
    }
  }

  async createRollbackPoint(migrationName) {
    // ÂàõÂª∫Êï∞ÊçÆÂ∫ìÂø´ÁÖßÊàñÂ§á‰ªΩÁÇπ
    const rollbackPoint = {
      id: `rollback_${Date.now()}`,
      migration: migrationName,
      timestamp: new Date().toISOString(),
      databaseState: await this.captureDatabaseState()
    };

    // ‰øùÂ≠òÂõûÊªöÁÇπ‰ø°ÊÅØ
    await this.saveRollbackPoint(rollbackPoint);
    
    return rollbackPoint;
  }

  async captureDatabaseState() {
    // ÊçïËé∑ÂΩìÂâçÊï∞ÊçÆÂ∫ìÁä∂ÊÄÅ
    const [tables] = await this.sequelize.query("SHOW TABLES");
    const state = {};

    for (const table of tables) {
      const tableName = Object.values(table)[0];
      const [structure] = await this.sequelize.query(`DESCRIBE ${tableName}`);
      const [rowCount] = await this.sequelize.query(`SELECT COUNT(*) as count FROM ${tableName}`);
      
      state[tableName] = {
        structure,
        rowCount: rowCount[0].count
      };
    }

    return state;
  }

  async rollbackToPoint(rollbackPointId) {
    const rollbackPoint = await this.getRollbackPoint(rollbackPointId);
    
    if (!rollbackPoint) {
      throw new Error(`Rollback point not found: ${rollbackPointId}`);
    }

    console.log(`üîÑ Rolling back to point: ${rollbackPointId}`);
    
    // ÊâæÂà∞ÈúÄË¶ÅÂõûÊªöÁöÑÊâÄÊúâËøÅÁßª
    const currentMigrations = await this.getExecutedMigrations();
    const targetIndex = this.rollbackHistory.findIndex(
      h => h.rollbackPoint.id === rollbackPointId
    );

    if (targetIndex === -1) {
      throw new Error(`Cannot determine rollback path to: ${rollbackPointId}`);
    }

    // ÊâßË°åÂõûÊªö
    const migrationsToRollback = currentMigrations.slice(0, targetIndex + 1);
    for (const migration of migrationsToRollback.reverse()) {
      await this.rollbackSingleMigration(migration);
    }

    console.log(`‚úÖ Successfully rolled back to point: ${rollbackPointId}`);
  }

  async getExecutedMigrations() {
    try {
      const [results] = await this.sequelize.query(
        "SELECT name FROM SequelizeMeta ORDER BY name DESC"
      );
      return results.map(r => r.name);
    } catch (error) {
      console.warn('Migration table not found, assuming no migrations executed');
      return [];
    }
  }

  async updateMigrationStatus(migrationName, status, transaction) {
    if (status === 'down') {
      await this.sequelize.query(
        "DELETE FROM SequelizeMeta WHERE name = :name",
        {
          replacements: { name: migrationName },
          transaction
        }
      );
    }
  }

  async saveRollbackPoint(rollbackPoint) {
    const filePath = path.join(this.migrationPath, '../rollback-points', `${rollbackPoint.id}.json`);
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, JSON.stringify(rollbackPoint, null, 2));
  }

  async getRollbackPoint(rollbackPointId) {
    try {
      const filePath = path.join(this.migrationPath, '../rollback-points', `${rollbackPointId}.json`);
      const content = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      return null;
    }
  }

  getRollbackHistory() {
    return this.rollbackHistory;
  }
}

module.exports = MigrationRollback;
```

### 3. Êï∞ÊçÆÂ§á‰ªΩ‰∏éÊÅ¢Â§ç

```javascript
// backup-restore.js
const { exec } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

class BackupRestore {
  constructor(config) {
    this.config = config;
    this.backupPath = config.backupPath || './backups';
  }

  async createBackup(name) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupName = `${name}_${timestamp}`;
    const backupFile = path.join(this.backupPath, `${backupName}.sql`);

    await fs.mkdir(this.backupPath, { recursive: true });

    console.log(`üì¶ Creating backup: ${backupName}`);

    try {
      // MySQLÂ§á‰ªΩ
      if (this.config.dialect === 'mysql') {
        await this.createMySQLBackup(backupFile);
      }
      // PostgreSQLÂ§á‰ªΩ
      else if (this.config.dialect === 'postgres') {
        await this.createPostgreSQLBackup(backupFile);
      }

      // ÂàõÂª∫Â§á‰ªΩÂÖÉÊï∞ÊçÆ
      const metadata = {
        name: backupName,
        file: backupFile,
        createdAt: new Date().toISOString(),
        database: this.config.database,
        size: (await fs.stat(backupFile)).size,
        checksum: await this.calculateChecksum(backupFile)
      };

      await this.saveBackupMetadata(backupName, metadata);
      
      console.log(`‚úÖ Backup created: ${backupFile}`);
      return metadata;

    } catch (error) {
      console.error(`‚ùå Backup failed: ${error.message}`);
      throw error;
    }
  }

  async createMySQLBackup(backupFile) {
    const command = `mysqldump -h ${this.config.host} -u ${this.config.username} -p${this.config.password} ${this.config.database} > ${backupFile}`;
    
    return new Promise((resolve, reject) => {
      exec(command, (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve(stdout);
        }
      });
    });
  }

  async createPostgreSQLBackup(backupFile) {
    const command = `pg_dump -h ${this.config.host} -U ${this.config.username} -d ${this.config.database} -f ${backupFile}`;
    
    return new Promise((resolve, reject) => {
      const child = exec(command, (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve(stdout);
        }
      });

      // ËÆæÁΩÆÂØÜÁ†ÅÁéØÂ¢ÉÂèòÈáè
      child.env.PGPASSWORD = this.config.password;
    });
  }

  async restoreBackup(backupName) {
    console.log(`üîÑ Restoring backup: ${backupName}`);

    try {
      const metadata = await this.getBackupMetadata(backupName);
      if (!metadata) {
        throw new Error(`Backup metadata not found: ${backupName}`);
      }

      // È™åËØÅÂ§á‰ªΩÊñá‰ª∂
      await this.verifyBackup(metadata);

      // ÂàõÂª∫ÊÅ¢Â§çÂâçÂ§á‰ªΩ
      const preRestoreBackup = await this.createBackup('pre-restore');
      
      // ÊâßË°åÊÅ¢Â§ç
      if (this.config.dialect === 'mysql') {
        await this.restoreMySQLBackup(metadata.file);
      } else if (this.config.dialect === 'postgres') {
        await this.restorePostgreSQLBackup(metadata.file);
      }

      console.log(`‚úÖ Backup restored successfully: ${backupName}`);
      
      return {
        restored: metadata,
        preRestoreBackup
      };

    } catch (error) {
      console.error(`‚ùå Restore failed: ${error.message}`);
      throw error;
    }
  }

  async restoreMySQLBackup(backupFile) {
    const command = `mysql -h ${this.config.host} -u ${this.config.username} -p${this.config.password} ${this.config.database} < ${backupFile}`;
    
    return new Promise((resolve, reject) => {
      exec(command, (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve(stdout);
        }
      });
    });
  }

  async restorePostgreSQLBackup(backupFile) {
    // ÂÖàÂà†Èô§Áé∞ÊúâÊï∞ÊçÆÂ∫ìÔºàÂèØÈÄâÔºâ
    // const dropCommand = `dropdb -h ${this.config.host} -U ${this.config.username} ${this.config.database}`;
    // const createCommand = `createdb -h ${this.config.host} -U ${this.config.username} ${this.config.database}`;
    
    const restoreCommand = `psql -h ${this.config.host} -U ${this.config.username} -d ${this.config.database} -f ${backupFile}`;
    
    return new Promise((resolve, reject) => {
      const child = exec(restoreCommand, (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve(stdout);
        }
      });

      child.env.PGPASSWORD = this.config.password;
    });
  }

  async verifyBackup(metadata) {
    // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
    try {
      await fs.access(metadata.file);
    } catch (error) {
      throw new Error(`Backup file not found: ${metadata.file}`);
    }

    // È™åËØÅÊñá‰ª∂ÂÆåÊï¥ÊÄß
    const currentChecksum = await this.calculateChecksum(metadata.file);
    if (currentChecksum !== metadata.checksum) {
      throw new Error(`Backup file corrupted: checksum mismatch`);
    }

    console.log(`‚úÖ Backup verified: ${metadata.name}`);
  }

  async calculateChecksum(filePath) {
    const crypto = require('crypto');
    const fileBuffer = await fs.readFile(filePath);
    const hashSum = crypto.createHash('sha256');
    hashSum.update(fileBuffer);
    return hashSum.digest('hex');
  }

  async saveBackupMetadata(backupName, metadata) {
    const metadataFile = path.join(this.backupPath, `${backupName}.metadata.json`);
    await fs.writeFile(metadataFile, JSON.stringify(metadata, null, 2));
  }

  async getBackupMetadata(backupName) {
    try {
      const metadataFile = path.join(this.backupPath, `${backupName}.metadata.json`);
      const content = await fs.readFile(metadataFile, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      return null;
    }
  }

  async listBackups() {
    try {
      const files = await fs.readdir(this.backupPath);
      const metadataFiles = files.filter(file => file.endsWith('.metadata.json'));
      
      const backups = [];
      for (const file of metadataFiles) {
        const content = await fs.readFile(path.join(this.backupPath, file), 'utf-8');
        backups.push(JSON.parse(content));
      }

      return backups.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    } catch (error) {
      console.error('Failed to list backups:', error.message);
      return [];
    }
  }

  async cleanupOldBackups(retentionDays = 30) {
    const backups = await this.listBackups();
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - retentionDays);

    const backupsToDelete = backups.filter(backup => 
      new Date(backup.createdAt) < cutoffDate
    );

    console.log(`üßπ Cleaning up ${backupsToDelete.length} old backups...`);

    for (const backup of backupsToDelete) {
      try {
        await fs.unlink(backup.file);
        await fs.unlink(backup.file.replace('.sql', '.metadata.json'));
        console.log(`üóëÔ∏è  Deleted: ${backup.name}`);
      } catch (error) {
        console.error(`Failed to delete backup ${backup.name}:`, error.message);
      }
    }

    console.log(`‚úÖ Cleanup completed`);
  }
}

module.exports = BackupRestore;
```

## üöÄ Ëá™Âä®ÂåñÂõûÊªöÁ≥ªÁªü

### Êô∫ËÉΩÂõûÊªöÂÜ≥Á≠ñ

```javascript
// intelligent-rollback.js
class IntelligentRollback {
  constructor(config) {
    this.config = config;
    this.healthChecks = [];
    this.rollbackTriggers = [];
    this.rollbackStrategies = new Map();
  }

  addHealthCheck(name, checkFunction, weight = 1) {
    this.healthChecks.push({
      name,
      check: checkFunction,
      weight,
      enabled: true
    });
  }

  addRollbackTrigger(name, condition, strategy) {
    this.rollbackTriggers.push({
      name,
      condition,
      strategy,
      enabled: true
    });
  }

  async evaluateSystemHealth() {
    console.log('üîç Evaluating system health...');
    
    const results = [];
    let totalScore = 0;
    let maxScore = 0;

    for (const healthCheck of this.healthChecks) {
      if (!healthCheck.enabled) continue;

      try {
        const result = await healthCheck.check();
        const score = result.healthy ? healthCheck.weight : 0;
        
        results.push({
          name: healthCheck.name,
          healthy: result.healthy,
          score,
          weight: healthCheck.weight,
          details: result.details || {}
        });

        totalScore += score;
        maxScore += healthCheck.weight;

      } catch (error) {
        results.push({
          name: healthCheck.name,
          healthy: false,
          score: 0,
          weight: healthCheck.weight,
          error: error.message
        });
        
        maxScore += healthCheck.weight;
      }
    }

    const healthPercentage = maxScore > 0 ? (totalScore / maxScore) * 100 : 0;
    
    return {
      healthy: healthPercentage >= this.config.healthThreshold,
      percentage: healthPercentage,
      details: results,
      timestamp: new Date().toISOString()
    };
  }

  async shouldTriggerRollback(context = {}) {
    const healthStatus = await this.evaluateSystemHealth();
    
    // Ê£ÄÊü•ÂÅ•Â∫∑Áä∂ÊÄÅËß¶ÂèëÂô®
    if (!healthStatus.healthy) {
      return {
        shouldRollback: true,
        reason: 'System health below threshold',
        strategy: 'immediate',
        healthStatus
      };
    }

    // Ê£ÄÊü•Ëá™ÂÆö‰πâËß¶ÂèëÂô®
    for (const trigger of this.rollbackTriggers) {
      if (!trigger.enabled) continue;

      try {
        const shouldTrigger = await trigger.condition(context, healthStatus);
        
        if (shouldTrigger) {
          return {
            shouldRollback: true,
            reason: `Trigger activated: ${trigger.name}`,
            strategy: trigger.strategy,
            healthStatus
          };
        }
      } catch (error) {
        console.error(`Trigger evaluation failed: ${trigger.name}`, error.message);
      }
    }

    return {
      shouldRollback: false,
      healthStatus
    };
  }

  async executeRollback(strategy, context = {}) {
    console.log(`üîÑ Executing rollback strategy: ${strategy}`);
    
    const rollbackFunction = this.rollbackStrategies.get(strategy);
    if (!rollbackFunction) {
      throw new Error(`Unknown rollback strategy: ${strategy}`);
    }

    const startTime = Date.now();
    
    try {
      // ÂàõÂª∫ÂõûÊªöÂâçÂø´ÁÖß
      const preRollbackSnapshot = await this.createSnapshot('pre-rollback');
      
      // ÊâßË°åÂõûÊªö
      const result = await rollbackFunction(context);
      
      const duration = Date.now() - startTime;
      
      // È™åËØÅÂõûÊªöÁªìÊûú
      const postRollbackHealth = await this.evaluateSystemHealth();
      
      const rollbackResult = {
        success: true,
        strategy,
        duration,
        preRollbackSnapshot,
        result,
        postRollbackHealth,
        timestamp: new Date().toISOString()
      };

      console.log(`‚úÖ Rollback completed successfully in ${duration}ms`);
      
      // ËÆ∞ÂΩïÂõûÊªöÂéÜÂè≤
      await this.recordRollback(rollbackResult);
      
      return rollbackResult;

    } catch (error) {
      const duration = Date.now() - startTime;
      
      console.error(`‚ùå Rollback failed after ${duration}ms:`, error.message);
      
      const rollbackResult = {
        success: false,
        strategy,
        duration,
        error: error.message,
        timestamp: new Date().toISOString()
      };

      await this.recordRollback(rollbackResult);
      throw error;
    }
  }

  registerRollbackStrategy(name, rollbackFunction) {
    this.rollbackStrategies.set(name, rollbackFunction);
    console.log(`üìù Registered rollback strategy: ${name}`);
  }

  async createSnapshot(name) {
    // ÂàõÂª∫Á≥ªÁªüÂø´ÁÖß
    return {
      id: `snapshot_${Date.now()}`,
      name,
      timestamp: new Date().toISOString(),
      databaseState: await this.captureDatabaseState(),
      applicationState: await this.captureApplicationState()
    };
  }

  async captureDatabaseState() {
    // ÂÆûÁé∞Êï∞ÊçÆÂ∫ìÁä∂ÊÄÅÊçïËé∑
    return {
      migrations: await this.getExecutedMigrations(),
      tableCount: await this.getTableCount(),
      recordCounts: await this.getRecordCounts()
    };
  }

  async captureApplicationState() {
    // ÂÆûÁé∞Â∫îÁî®Áä∂ÊÄÅÊçïËé∑
    return {
      version: process.env.APP_VERSION,
      environment: process.env.NODE_ENV,
      uptime: process.uptime()
    };
  }

  async recordRollback(rollbackResult) {
    // ËÆ∞ÂΩïÂõûÊªöÂéÜÂè≤Âà∞Êï∞ÊçÆÂ∫ìÊàñÊñá‰ª∂
    console.log('üìù Recording rollback:', rollbackResult);
  }

  // È¢ÑÂÆö‰πâÂÅ•Â∫∑Ê£ÄÊü•
  getDatabaseHealthCheck() {
    return async () => {
      try {
        // Ê£ÄÊü•Êï∞ÊçÆÂ∫ìËøûÊé•
        await this.sequelize.authenticate();
        
        // Ê£ÄÊü•ÂÖ≥ÈîÆË°®
        const criticalTables = ['users', 'orders', 'products'];
        for (const table of criticalTables) {
          await this.sequelize.query(`SELECT 1 FROM ${table} LIMIT 1`);
        }

        return {
          healthy: true,
          details: {
            connection: 'ok',
            tables: 'accessible'
          }
        };
      } catch (error) {
        return {
          healthy: false,
          details: {
            error: error.message
          }
        };
      }
    };
  }

  getPerformanceHealthCheck() {
    return async () => {
      try {
        const startTime = Date.now();
        
        // ÊâßË°åÊÄßËÉΩÊµãËØïÊü•ËØ¢
        await this.sequelize.query('SELECT COUNT(*) FROM users');
        
        const queryTime = Date.now() - startTime;
        const healthy = queryTime < this.config.maxQueryTime;

        return {
          healthy,
          details: {
            queryTime,
            threshold: this.config.maxQueryTime
          }
        };
      } catch (error) {
        return {
          healthy: false,
          details: {
            error: error.message
          }
        };
      }
    };
  }
}

// ‰ΩøÁî®Á§∫‰æã
const intelligentRollback = new IntelligentRollback({
  healthThreshold: 80,
  maxQueryTime: 1000
});

// Ê≥®ÂÜåÂÅ•Â∫∑Ê£ÄÊü•
intelligentRollback.addHealthCheck(
  'database',
  intelligentRollback.getDatabaseHealthCheck(),
  3
);

intelligentRollback.addHealthCheck(
  'performance',
  intelligentRollback.getPerformanceHealthCheck(),
  2
);

// Ê≥®ÂÜåÂõûÊªöÁ≠ñÁï•
intelligentRollback.registerRollbackStrategy('immediate', async (context) => {
  // Á´ãÂç≥ÂõûÊªöÂà∞‰∏ä‰∏Ä‰∏™ÁâàÊú¨
  const migrationRollback = new MigrationRollback('./migrations', sequelize);
  return await migrationRollback.rollbackMigration(1);
});

intelligentRollback.registerRollbackStrategy('gradual', async (context) => {
  // ÈÄêÊ≠•ÂõûÊªö
  const migrationRollback = new MigrationRollback('./migrations', sequelize);
  return await migrationRollback.rollbackMigration(3);
});

module.exports = IntelligentRollback;
```

## üéØ ÊúÄ‰Ω≥ÂÆûË∑µ

### 1. ÂõûÊªöÊµãËØï

```javascript
// rollback-testing.js
class RollbackTesting {
  constructor(testEnvironment) {
    this.testEnvironment = testEnvironment;
    this.testResults = [];
  }

  async runRollbackTests() {
    console.log('üß™ Running rollback tests...');
    
    const tests = [
      this.testMigrationRollback,
      this.testDataIntegrityAfterRollback,
      this.testPerformanceAfterRollback,
      this.testApplicationFunctionalityAfterRollback
    ];

    for (const test of tests) {
      try {
        const result = await test.call(this);
        this.testResults.push(result);
        console.log(`‚úÖ Test passed: ${result.name}`);
      } catch (error) {
        this.testResults.push({
          name: test.name,
          success: false,
          error: error.message
        });
        console.error(`‚ùå Test failed: ${test.name}`, error.message);
      }
    }

    return this.generateTestReport();
  }

  async testMigrationRollback() {
    // ÊµãËØïËøÅÁßªÂõûÊªöÂäüËÉΩ
    const migrationRollback = new MigrationRollback('./migrations', this.testEnvironment.sequelize);
    
    // ÊâßË°å‰∏Ä‰∏™ËøÅÁßª
    await this.testEnvironment.runMigration('test_migration');
    
    // ÂõûÊªöËøÅÁßª
    await migrationRollback.rollbackMigration(1);
    
    // È™åËØÅÂõûÊªöÁªìÊûú
    const migrations = await migrationRollback.getExecutedMigrations();
    const migrationExists = migrations.includes('test_migration');
    
    if (migrationExists) {
      throw new Error('Migration was not properly rolled back');
    }

    return {
      name: 'Migration Rollback',
      success: true,
      details: 'Migration successfully rolled back'
    };
  }

  async testDataIntegrityAfterRollback() {
    // ÊµãËØïÂõûÊªöÂêéÊï∞ÊçÆÂÆåÊï¥ÊÄß
    const backupRestore = new BackupRestore(this.testEnvironment.config);
    
    // ÂàõÂª∫ÊµãËØïÊï∞ÊçÆ
    await this.createTestData();
    
    // ÂàõÂª∫Â§á‰ªΩ
    const backup = await backupRestore.createBackup('integrity-test');
    
    // ‰øÆÊîπÊï∞ÊçÆ
    await this.modifyTestData();
    
    // ÊÅ¢Â§çÂ§á‰ªΩ
    await backupRestore.restoreBackup(backup.name);
    
    // È™åËØÅÊï∞ÊçÆÂÆåÊï¥ÊÄß
    const dataIntact = await this.verifyTestData();
    
    if (!dataIntact) {
      throw new Error('Data integrity compromised after rollback');
    }

    return {
      name: 'Data Integrity',
      success: true,
      details: 'Data integrity maintained after rollback'
    };
  }

  generateTestReport() {
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(r => r.success).length;
    const failedTests = totalTests - passedTests;

    return {
      summary: {
        total: totalTests,
        passed: passedTests,
        failed: failedTests,
        successRate: (passedTests / totalTests) * 100
      },
      details: this.testResults,
      timestamp: new Date().toISOString()
    };
  }
}
```

### 2. ÁõëÊéßÂíåÂëäË≠¶

```javascript
// rollback-monitoring.js
class RollbackMonitoring {
  constructor(alertingService) {
    this.alertingService = alertingService;
    this.metrics = {
      rollbacksExecuted: 0,
      rollbacksSuccessful: 0,
      rollbacksFailed: 0,
      averageRollbackTime: 0,
      lastRollback: null
    };
  }

  async monitorRollback(rollbackFunction, context) {
    const rollbackId = `rollback_${Date.now()}`;
    const startTime = Date.now();

    try {
      console.log(`üìä Monitoring rollback: ${rollbackId}`);
      
      // ÂèëÈÄÅÂºÄÂßãÂëäË≠¶
      await this.sendAlert('rollback_started', {
        rollbackId,
        context,
        timestamp: new Date().toISOString()
      });

      // ÊâßË°åÂõûÊªö
      const result = await rollbackFunction();
      
      const duration = Date.now() - startTime;
      
      // Êõ¥Êñ∞ÊåáÊ†á
      this.updateMetrics(true, duration);
      
      // ÂèëÈÄÅÊàêÂäüÂëäË≠¶
      await this.sendAlert('rollback_success', {
        rollbackId,
        duration,
        result,
        timestamp: new Date().toISOString()
      });

      return result;

    } catch (error) {
      const duration = Date.now() - startTime;
      
      // Êõ¥Êñ∞ÊåáÊ†á
      this.updateMetrics(false, duration);
      
      // ÂèëÈÄÅÂ§±Ë¥•ÂëäË≠¶
      await this.sendAlert('rollback_failure', {
        rollbackId,
        duration,
        error: error.message,
        timestamp: new Date().toISOString()
      });

      throw error;
    }
  }

  updateMetrics(success, duration) {
    this.metrics.rollbacksExecuted++;
    
    if (success) {
      this.metrics.rollbacksSuccessful++;
    } else {
      this.metrics.rollbacksFailed++;
    }

    // Êõ¥Êñ∞Âπ≥ÂùáÊó∂Èó¥
    const totalTime = this.metrics.averageRollbackTime * (this.metrics.rollbacksExecuted - 1);
    this.metrics.averageRollbackTime = (totalTime + duration) / this.metrics.rollbacksExecuted;
    
    this.metrics.lastRollback = new Date().toISOString();
  }

  async sendAlert(type, data) {
    const alertConfig = this.getAlertConfig(type);
    
    if (alertConfig.enabled) {
      await this.alertingService.send({
        type,
        severity: alertConfig.severity,
        title: alertConfig.title,
        message: this.formatAlertMessage(type, data),
        data
      });
    }
  }

  getAlertConfig(type) {
    const configs = {
      rollback_started: {
        enabled: true,
        severity: 'warning',
        title: 'Database Rollback Started'
      },
      rollback_success: {
        enabled: true,
        severity: 'info',
        title: 'Database Rollback Completed Successfully'
      },
      rollback_failure: {
        enabled: true,
        severity: 'critical',
        title: 'Database Rollback Failed'
      }
    };

    return configs[type] || { enabled: false };
  }

  formatAlertMessage(type, data) {
    switch (type) {
      case 'rollback_started':
        return `Database rollback ${data.rollbackId} has been initiated.`;
      
      case 'rollback_success':
        return `Database rollback ${data.rollbackId} completed successfully in ${data.duration}ms.`;
      
      case 'rollback_failure':
        return `Database rollback ${data.rollbackId} failed after ${data.duration}ms: ${data.error}`;
      
      default:
        return `Database rollback event: ${type}`;
    }
  }

  getMetrics() {
    return {
      ...this.metrics,
      successRate: this.metrics.rollbacksExecuted > 0 
        ? (this.metrics.rollbacksSuccessful / this.metrics.rollbacksExecuted) * 100 
        : 0
    };
  }
}

module.exports = RollbackMonitoring;
```

Êï∞ÊçÆÂ∫ìÂõûÊªöÊú∫Âà∂ÊòØÁ°Æ‰øùÁ≥ªÁªüÁ®≥ÂÆöÊÄßÂíåÊï∞ÊçÆÂÆâÂÖ®ÁöÑÈáçË¶Å‰øùÈöúÔºåÈÄöËøáÂêàÁêÜÁöÑËÆæËÆ°ÂíåËá™Âä®ÂåñÂ∑•ÂÖ∑ÂèØ‰ª•Â§ßÂ§ßÈôç‰ΩéÁ≥ªÁªüÈ£éÈô©ÔºÅ
