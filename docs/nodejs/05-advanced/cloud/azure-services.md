# Azure‰∫ëÊúçÂä°

## üìñ Ê¶ÇËø∞

Microsoft Azure ÊòØÂæÆËΩØÁöÑ‰∫ëËÆ°ÁÆóÂπ≥Âè∞ÔºåÊèê‰æõË∂ÖËøá200ÁßçÊúçÂä°ÔºåÂåÖÊã¨ËÆ°ÁÆó„ÄÅÂ≠òÂÇ®„ÄÅÁΩëÁªú„ÄÅÊï∞ÊçÆÂ∫ì„ÄÅAIÂíåÊú∫Âô®Â≠¶‰π†Á≠â„ÄÇÊú¨ÊñáÊ°£Â∞ÜËØ¶ÁªÜ‰ªãÁªçÂ¶Ç‰ΩïÂú®Node.jsÂ∫îÁî®‰∏≠ÈõÜÊàêÂêÑÁßçAzureÊúçÂä°„ÄÇ

## üéØ Â≠¶‰π†ÁõÆÊ†á

- ÊéåÊè°Azure SDKÁöÑ‰ΩøÁî®ÊñπÊ≥ï
- Â≠¶‰π†Ê†∏ÂøÉAzureÊúçÂä°ÁöÑÈõÜÊàê
- ‰∫ÜËß£AzureÊúçÂä°ÁöÑÊúÄ‰Ω≥ÂÆûË∑µ
- ÂÆûÁé∞ÂÆâÂÖ®ÁöÑAzureÊúçÂä°ËÆøÈóÆ

## üîß ÁéØÂ¢ÉÂáÜÂ§á

### 1. ÂÆâË£ÖAzure SDK

```bash
# AzureÊ†∏ÂøÉÂ∫ì
npm install @azure/identity @azure/core-auth

# Â≠òÂÇ®ÊúçÂä°
npm install @azure/storage-blob @azure/storage-queue

# Êï∞ÊçÆÂ∫ìÊúçÂä°
npm install @azure/cosmos @azure/data-tables

# Ê∂àÊÅØÊúçÂä°
npm install @azure/service-bus @azure/event-hubs

# AIÊúçÂä°
npm install @azure/cognitiveservices-textanalytics @azure/openai

# ÂáΩÊï∞ÂíåÂ∫îÁî®ÊúçÂä°
npm install @azure/functions-core @azure/app-configuration
```

### 2. Ë∫´‰ªΩÈ™åËØÅÈÖçÁΩÆ

```javascript
const { DefaultAzureCredential, ClientSecretCredential } = require('@azure/identity');

// ÊñπÊ≥ï1: ÈªòËÆ§Âá≠ÊçÆÈìæ (Êé®Ëçê)
const credential = new DefaultAzureCredential();

// ÊñπÊ≥ï2: ÊúçÂä°‰∏ª‰ΩìËÆ§ËØÅ
const credential2 = new ClientSecretCredential(
  process.env.AZURE_TENANT_ID,
  process.env.AZURE_CLIENT_ID,
  process.env.AZURE_CLIENT_SECRET
);

// ÊñπÊ≥ï3: ÁéØÂ¢ÉÂèòÈáèÈÖçÁΩÆ
/*
AZURE_TENANT_ID=your-tenant-id
AZURE_CLIENT_ID=your-client-id
AZURE_CLIENT_SECRET=your-client-secret
AZURE_SUBSCRIPTION_ID=your-subscription-id
*/
```

## üóÑÔ∏è Blob Storage ÂØπË±°Â≠òÂÇ®

### 1. Âü∫Êú¨Êìç‰Ωú

```javascript
const { BlobServiceClient } = require('@azure/storage-blob');
const { DefaultAzureCredential } = require('@azure/identity');

class AzureBlobService {
  constructor() {
    const accountName = process.env.AZURE_STORAGE_ACCOUNT_NAME;
    const credential = new DefaultAzureCredential();
    
    this.blobServiceClient = new BlobServiceClient(
      `https://${accountName}.blob.core.windows.net`,
      credential
    );
    
    this.containerName = process.env.AZURE_CONTAINER_NAME;
  }

  // ‰∏ä‰º†Êñá‰ª∂
  async uploadFile(fileName, fileBuffer, options = {}) {
    try {
      const containerClient = this.blobServiceClient.getContainerClient(this.containerName);
      const blockBlobClient = containerClient.getBlockBlobClient(fileName);
      
      const uploadResponse = await blockBlobClient.upload(fileBuffer, fileBuffer.length, {
        blobHTTPHeaders: {
          blobContentType: options.contentType || 'application/octet-stream',
        },
        metadata: options.metadata || {},
        tags: options.tags || {},
      });
      
      return {
        success: true,
        etag: uploadResponse.etag,
        lastModified: uploadResponse.lastModified,
        url: blockBlobClient.url,
      };
    } catch (error) {
      throw new Error(`‰∏ä‰º†Â§±Ë¥•: ${error.message}`);
    }
  }

  // ‰∏ãËΩΩÊñá‰ª∂
  async downloadFile(fileName) {
    try {
      const containerClient = this.blobServiceClient.getContainerClient(this.containerName);
      const blockBlobClient = containerClient.getBlockBlobClient(fileName);
      
      const downloadResponse = await blockBlobClient.download();
      return downloadResponse.readableStreamBody;
    } catch (error) {
      throw new Error(`‰∏ãËΩΩÂ§±Ë¥•: ${error.message}`);
    }
  }

  // ÁîüÊàêSAS URL
  async generateSasUrl(fileName, permissions = 'r', expiryMinutes = 60) {
    const { generateBlobSASQueryParameters, BlobSASPermissions } = require('@azure/storage-blob');
    
    const containerClient = this.blobServiceClient.getContainerClient(this.containerName);
    const blockBlobClient = containerClient.getBlockBlobClient(fileName);
    
    const expiresOn = new Date();
    expiresOn.setMinutes(expiresOn.getMinutes() + expiryMinutes);
    
    const sasOptions = {
      containerName: this.containerName,
      blobName: fileName,
      permissions: BlobSASPermissions.parse(permissions),
      expiresOn,
    };
    
    const sasToken = generateBlobSASQueryParameters(
      sasOptions,
      this.blobServiceClient.credential
    ).toString();
    
    return `${blockBlobClient.url}?${sasToken}`;
  }

  // ÂàóÂá∫Êñá‰ª∂
  async listFiles(prefix = '') {
    try {
      const containerClient = this.blobServiceClient.getContainerClient(this.containerName);
      const files = [];
      
      for await (const blob of containerClient.listBlobsFlat({ prefix })) {
        files.push({
          name: blob.name,
          size: blob.properties.contentLength,
          lastModified: blob.properties.lastModified,
          contentType: blob.properties.contentType,
        });
      }
      
      return files;
    } catch (error) {
      throw new Error(`ÂàóÂá∫Êñá‰ª∂Â§±Ë¥•: ${error.message}`);
    }
  }

  // Âà†Èô§Êñá‰ª∂
  async deleteFile(fileName) {
    try {
      const containerClient = this.blobServiceClient.getContainerClient(this.containerName);
      const blockBlobClient = containerClient.getBlockBlobClient(fileName);
      
      await blockBlobClient.delete();
      return { success: true };
    } catch (error) {
      throw new Error(`Âà†Èô§Â§±Ë¥•: ${error.message}`);
    }
  }
}

// ‰ΩøÁî®Á§∫‰æã
const blobService = new AzureBlobService();

app.post('/upload', upload.single('file'), async (req, res) => {
  try {
    const fileName = `${Date.now()}-${req.file.originalname}`;
    const result = await blobService.uploadFile(fileName, req.file.buffer, {
      contentType: req.file.mimetype,
      metadata: { uploadedBy: req.user.id },
    });
    
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 2. È´òÁ∫ßÂäüËÉΩ

```javascript
// Â§ßÊñá‰ª∂ÂàÜÂùó‰∏ä‰º†
class AzureBlobAdvanced extends AzureBlobService {
  async uploadLargeFile(fileName, fileStream, fileSize, options = {}) {
    const containerClient = this.blobServiceClient.getContainerClient(this.containerName);
    const blockBlobClient = containerClient.getBlockBlobClient(fileName);
    
    const blockSize = 4 * 1024 * 1024; // 4MB blocks
    const blockIds = [];
    
    try {
      let offset = 0;
      let blockIndex = 0;
      
      while (offset < fileSize) {
        const blockId = Buffer.from(`block-${blockIndex.toString().padStart(6, '0')}`).toString('base64');
        const blockSize2 = Math.min(blockSize, fileSize - offset);
        
        await blockBlobClient.stageBlock(blockId, fileStream, blockSize2);
        blockIds.push(blockId);
        
        offset += blockSize2;
        blockIndex++;
      }
      
      // Êèê‰∫§ÊâÄÊúâÂùó
      await blockBlobClient.commitBlockList(blockIds, {
        blobHTTPHeaders: {
          blobContentType: options.contentType,
        },
      });
      
      return { success: true, blockCount: blockIds.length };
    } catch (error) {
      throw new Error(`Â§ßÊñá‰ª∂‰∏ä‰º†Â§±Ë¥•: ${error.message}`);
    }
  }
}
```

## üóÉÔ∏è Cosmos DB Êï∞ÊçÆÂ∫ì

### 1. Âü∫Êú¨Êìç‰Ωú

```javascript
const { CosmosClient } = require('@azure/cosmos');

class CosmosDBService {
  constructor() {
    this.client = new CosmosClient({
      endpoint: process.env.COSMOS_DB_ENDPOINT,
      key: process.env.COSMOS_DB_KEY,
    });
    
    this.databaseId = process.env.COSMOS_DB_DATABASE;
    this.containerId = process.env.COSMOS_DB_CONTAINER;
  }

  async getContainer() {
    const database = this.client.database(this.databaseId);
    return database.container(this.containerId);
  }

  // ÂàõÂª∫ÊñáÊ°£
  async createDocument(document) {
    try {
      const container = await this.getContainer();
      const { resource } = await container.items.create({
        ...document,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });
      
      return resource;
    } catch (error) {
      throw new Error(`ÂàõÂª∫ÊñáÊ°£Â§±Ë¥•: ${error.message}`);
    }
  }

  // Ëé∑ÂèñÊñáÊ°£
  async getDocument(id, partitionKey) {
    try {
      const container = await this.getContainer();
      const { resource } = await container.item(id, partitionKey).read();
      return resource;
    } catch (error) {
      if (error.code === 404) {
        return null;
      }
      throw new Error(`Ëé∑ÂèñÊñáÊ°£Â§±Ë¥•: ${error.message}`);
    }
  }

  // Êõ¥Êñ∞ÊñáÊ°£
  async updateDocument(id, partitionKey, updates) {
    try {
      const container = await this.getContainer();
      const { resource: existingDoc } = await container.item(id, partitionKey).read();
      
      const updatedDoc = {
        ...existingDoc,
        ...updates,
        updatedAt: new Date().toISOString(),
      };
      
      const { resource } = await container.item(id, partitionKey).replace(updatedDoc);
      return resource;
    } catch (error) {
      throw new Error(`Êõ¥Êñ∞ÊñáÊ°£Â§±Ë¥•: ${error.message}`);
    }
  }

  // Êü•ËØ¢ÊñáÊ°£
  async queryDocuments(querySpec, options = {}) {
    try {
      const container = await this.getContainer();
      const { resources } = await container.items.query(querySpec, options).fetchAll();
      return resources;
    } catch (error) {
      throw new Error(`Êü•ËØ¢ÊñáÊ°£Â§±Ë¥•: ${error.message}`);
    }
  }

  // Âà†Èô§ÊñáÊ°£
  async deleteDocument(id, partitionKey) {
    try {
      const container = await this.getContainer();
      await container.item(id, partitionKey).delete();
      return { success: true };
    } catch (error) {
      throw new Error(`Âà†Èô§ÊñáÊ°£Â§±Ë¥•: ${error.message}`);
    }
  }
}

// ‰ΩøÁî®Á§∫‰æã
const cosmosService = new CosmosDBService();

app.post('/users', async (req, res) => {
  try {
    const user = await cosmosService.createDocument({
      id: req.body.id,
      email: req.body.email,
      name: req.body.name,
      partitionKey: req.body.email, // ‰ΩøÁî®email‰Ωú‰∏∫ÂàÜÂå∫ÈîÆ
    });
    
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/users/search', async (req, res) => {
  try {
    const querySpec = {
      query: 'SELECT * FROM c WHERE CONTAINS(c.name, @searchTerm)',
      parameters: [
        { name: '@searchTerm', value: req.query.q }
      ],
    };
    
    const users = await cosmosService.queryDocuments(querySpec);
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 2. ÊâπÈáèÊìç‰ΩúÂíå‰∫ãÂä°

```javascript
class CosmosDBBatchService extends CosmosDBService {
  // ÊâπÈáèÊìç‰Ωú
  async batchOperations(operations) {
    try {
      const container = await this.getContainer();
      const { resources } = await container.items.batch(operations);
      return resources;
    } catch (error) {
      throw new Error(`ÊâπÈáèÊìç‰ΩúÂ§±Ë¥•: ${error.message}`);
    }
  }

  // ‰∫ãÂä°Êìç‰Ωú
  async transactionalBatch(partitionKey, operations) {
    try {
      const container = await this.getContainer();
      const { resources } = await container.items.batch(operations, partitionKey);
      return resources;
    } catch (error) {
      throw new Error(`‰∫ãÂä°Êìç‰ΩúÂ§±Ë¥•: ${error.message}`);
    }
  }
}

// ‰ΩøÁî®Á§∫‰æã
const batchOperations = [
  {
    operationType: 'Create',
    resourceBody: { id: '1', name: 'User 1', partitionKey: 'users' }
  },
  {
    operationType: 'Create', 
    resourceBody: { id: '2', name: 'User 2', partitionKey: 'users' }
  },
  {
    operationType: 'Upsert',
    resourceBody: { id: '3', name: 'User 3', partitionKey: 'users' }
  }
];

await cosmosService.batchOperations(batchOperations);
```

## üöå Service Bus Ê∂àÊÅØÊúçÂä°

### 1. ÈòüÂàóÊìç‰Ωú

```javascript
const { ServiceBusClient } = require('@azure/service-bus');

class ServiceBusService {
  constructor() {
    this.client = new ServiceBusClient(
      process.env.SERVICE_BUS_CONNECTION_STRING
    );
  }

  // ÂèëÈÄÅÊ∂àÊÅØÂà∞ÈòüÂàó
  async sendToQueue(queueName, messages) {
    const sender = this.client.createSender(queueName);
    
    try {
      if (Array.isArray(messages)) {
        await sender.sendMessages(messages);
      } else {
        await sender.sendMessages([messages]);
      }
      
      return { success: true };
    } catch (error) {
      throw new Error(`ÂèëÈÄÅÊ∂àÊÅØÂ§±Ë¥•: ${error.message}`);
    } finally {
      await sender.close();
    }
  }

  // Êé•Êî∂ÈòüÂàóÊ∂àÊÅØ
  async receiveFromQueue(queueName, maxMessages = 10) {
    const receiver = this.client.createReceiver(queueName);
    
    try {
      const messages = await receiver.receiveMessages(maxMessages, {
        maxWaitTimeInMs: 60000, // 60Áßí
      });
      
      const results = [];
      for (const message of messages) {
        try {
          // Â§ÑÁêÜÊ∂àÊÅØ
          const body = typeof message.body === 'string' 
            ? JSON.parse(message.body) 
            : message.body;
            
          results.push({
            messageId: message.messageId,
            body,
            enqueuedTimeUtc: message.enqueuedTimeUtc,
          });
          
          // ÂÆåÊàêÊ∂àÊÅØÂ§ÑÁêÜ
          await receiver.completeMessage(message);
        } catch (error) {
          console.error('Â§ÑÁêÜÊ∂àÊÅØÂ§±Ë¥•:', error);
          // Â∞ÜÊ∂àÊÅØÊ†áËÆ∞‰∏∫Ê≠ª‰ø°
          await receiver.deadLetterMessage(message, {
            deadLetterReason: 'ProcessingError',
            deadLetterErrorDescription: error.message,
          });
        }
      }
      
      return results;
    } catch (error) {
      throw new Error(`Êé•Êî∂Ê∂àÊÅØÂ§±Ë¥•: ${error.message}`);
    } finally {
      await receiver.close();
    }
  }

  // Ê∂àÊÅØÂ§ÑÁêÜÂô®
  async processQueueMessages(queueName, messageHandler) {
    const receiver = this.client.createReceiver(queueName);
    
    receiver.subscribe({
      processMessage: async (message) => {
        try {
          const body = typeof message.body === 'string' 
            ? JSON.parse(message.body) 
            : message.body;
            
          await messageHandler(body, message);
          await receiver.completeMessage(message);
        } catch (error) {
          console.error('Â§ÑÁêÜÊ∂àÊÅØÂ§±Ë¥•:', error);
          await receiver.deadLetterMessage(message, {
            deadLetterReason: 'ProcessingError',
            deadLetterErrorDescription: error.message,
          });
        }
      },
      processError: async (args) => {
        console.error('Service BusÈîôËØØ:', args.error);
      },
    });
    
    return receiver;
  }
}

// ‰ΩøÁî®Á§∫‰æã
const serviceBusService = new ServiceBusService();

// ÂèëÈÄÅÊ∂àÊÅØ
app.post('/send-message', async (req, res) => {
  try {
    await serviceBusService.sendToQueue('processing-queue', {
      body: {
        taskType: 'process-order',
        orderId: req.body.orderId,
        userId: req.body.userId,
      },
      applicationProperties: {
        priority: req.body.priority || 'normal',
        source: 'api',
      },
    });
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∂àÊÅØÂ§ÑÁêÜÂô®
serviceBusService.processQueueMessages('processing-queue', async (message, rawMessage) => {
  console.log('Â§ÑÁêÜÊ∂àÊÅØ:', message);
  
  switch (message.taskType) {
    case 'process-order':
      await processOrder(message.orderId);
      break;
    case 'send-email':
      await sendEmail(message.recipient, message.content);
      break;
    default:
      console.warn('Êú™Áü•‰ªªÂä°Á±ªÂûã:', message.taskType);
  }
});
```

### 2. ‰∏ªÈ¢òÂíåËÆ¢ÈòÖ

```javascript
class ServiceBusTopicService extends ServiceBusService {
  // ÂèëÈÄÅÂà∞‰∏ªÈ¢ò
  async sendToTopic(topicName, message) {
    const sender = this.client.createSender(topicName);
    
    try {
      await sender.sendMessages([message]);
      return { success: true };
    } finally {
      await sender.close();
    }
  }

  // ËÆ¢ÈòÖ‰∏ªÈ¢òÊ∂àÊÅØ
  async subscribeToTopic(topicName, subscriptionName, messageHandler) {
    const receiver = this.client.createReceiver(topicName, subscriptionName);
    
    receiver.subscribe({
      processMessage: async (message) => {
        try {
          const body = typeof message.body === 'string' 
            ? JSON.parse(message.body) 
            : message.body;
            
          await messageHandler(body, message);
          await receiver.completeMessage(message);
        } catch (error) {
          console.error('Â§ÑÁêÜ‰∏ªÈ¢òÊ∂àÊÅØÂ§±Ë¥•:', error);
          await receiver.deadLetterMessage(message);
        }
      },
      processError: async (args) => {
        console.error('‰∏ªÈ¢òËÆ¢ÈòÖÈîôËØØ:', args.error);
      },
    });
    
    return receiver;
  }
}

// ‰ΩøÁî®Á§∫‰æã
const topicService = new ServiceBusTopicService();

// ÂèëÂ∏É‰∫ã‰ª∂
await topicService.sendToTopic('user-events', {
  body: {
    eventType: 'user-registered',
    userId: '12345',
    email: 'user@example.com',
    timestamp: new Date().toISOString(),
  },
  applicationProperties: {
    eventType: 'user-registered',
  },
});

// ËÆ¢ÈòÖ‰∫ã‰ª∂
topicService.subscribeToTopic('user-events', 'email-service', async (message) => {
  if (message.eventType === 'user-registered') {
    await sendWelcomeEmail(message.email);
  }
});
```

## üß† Cognitive Services AIÊúçÂä°

### 1. ÊñáÊú¨ÂàÜÊûê

```javascript
const { TextAnalyticsClient } = require('@azure/cognitiveservices-textanalytics');

class TextAnalyticsService {
  constructor() {
    this.client = new TextAnalyticsClient(
      process.env.TEXT_ANALYTICS_ENDPOINT,
      new DefaultAzureCredential()
    );
  }

  // ÊÉÖÊÑüÂàÜÊûê
  async analyzeSentiment(documents) {
    try {
      const results = await this.client.analyzeSentiment(documents);
      
      return results.map(result => ({
        id: result.id,
        sentiment: result.sentiment,
        confidence: result.confidenceScores,
        sentences: result.sentences?.map(sentence => ({
          text: sentence.text,
          sentiment: sentence.sentiment,
          confidence: sentence.confidenceScores,
        })),
      }));
    } catch (error) {
      throw new Error(`ÊÉÖÊÑüÂàÜÊûêÂ§±Ë¥•: ${error.message}`);
    }
  }

  // ÂÖ≥ÈîÆËØçÊèêÂèñ
  async extractKeyPhrases(documents) {
    try {
      const results = await this.client.extractKeyPhrases(documents);
      
      return results.map(result => ({
        id: result.id,
        keyPhrases: result.keyPhrases,
      }));
    } catch (error) {
      throw new Error(`ÂÖ≥ÈîÆËØçÊèêÂèñÂ§±Ë¥•: ${error.message}`);
    }
  }

  // ÂÆû‰ΩìËØÜÂà´
  async recognizeEntities(documents) {
    try {
      const results = await this.client.recognizeEntities(documents);
      
      return results.map(result => ({
        id: result.id,
        entities: result.entities?.map(entity => ({
          text: entity.text,
          category: entity.category,
          confidence: entity.confidenceScore,
          offset: entity.offset,
          length: entity.length,
        })),
      }));
    } catch (error) {
      throw new Error(`ÂÆû‰ΩìËØÜÂà´Â§±Ë¥•: ${error.message}`);
    }
  }

  // ËØ≠Ë®ÄÊ£ÄÊµã
  async detectLanguage(documents) {
    try {
      const results = await this.client.detectLanguage(documents);
      
      return results.map(result => ({
        id: result.id,
        primaryLanguage: result.primaryLanguage,
      }));
    } catch (error) {
      throw new Error(`ËØ≠Ë®ÄÊ£ÄÊµãÂ§±Ë¥•: ${error.message}`);
    }
  }
}

// ‰ΩøÁî®Á§∫‰æã
const textAnalytics = new TextAnalyticsService();

app.post('/analyze-text', async (req, res) => {
  try {
    const documents = [
      { id: '1', text: req.body.text, language: 'zh' }
    ];
    
    const [sentiment, keyPhrases, entities] = await Promise.all([
      textAnalytics.analyzeSentiment(documents),
      textAnalytics.extractKeyPhrases(documents),
      textAnalytics.recognizeEntities(documents),
    ]);
    
    res.json({
      sentiment: sentiment[0],
      keyPhrases: keyPhrases[0],
      entities: entities[0],
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 2. OpenAI ÈõÜÊàê

```javascript
const { OpenAIClient } = require('@azure/openai');

class AzureOpenAIService {
  constructor() {
    this.client = new OpenAIClient(
      process.env.AZURE_OPENAI_ENDPOINT,
      new DefaultAzureCredential()
    );
    this.deploymentName = process.env.AZURE_OPENAI_DEPLOYMENT_NAME;
  }

  // ÊñáÊú¨ÁîüÊàê
  async generateText(prompt, options = {}) {
    try {
      const response = await this.client.getCompletions(this.deploymentName, {
        prompt: [prompt],
        maxTokens: options.maxTokens || 100,
        temperature: options.temperature || 0.7,
        topP: options.topP || 1,
        frequencyPenalty: options.frequencyPenalty || 0,
        presencePenalty: options.presencePenalty || 0,
      });
      
      return {
        text: response.choices[0]?.text?.trim(),
        finishReason: response.choices[0]?.finishReason,
        usage: response.usage,
      };
    } catch (error) {
      throw new Error(`ÊñáÊú¨ÁîüÊàêÂ§±Ë¥•: ${error.message}`);
    }
  }

  // ËÅäÂ§©ÂØπËØù
  async chatCompletion(messages, options = {}) {
    try {
      const response = await this.client.getChatCompletions(this.deploymentName, {
        messages,
        maxTokens: options.maxTokens || 150,
        temperature: options.temperature || 0.7,
      });
      
      return {
        message: response.choices[0]?.message,
        finishReason: response.choices[0]?.finishReason,
        usage: response.usage,
      };
    } catch (error) {
      throw new Error(`ËÅäÂ§©ÂØπËØùÂ§±Ë¥•: ${error.message}`);
    }
  }

  // ÊñáÊú¨ÂµåÂÖ•
  async getEmbeddings(texts) {
    try {
      const response = await this.client.getEmbeddings(
        process.env.AZURE_OPENAI_EMBEDDING_DEPLOYMENT,
        texts
      );
      
      return response.data.map(item => ({
        index: item.index,
        embedding: item.embedding,
      }));
    } catch (error) {
      throw new Error(`Ëé∑ÂèñÂµåÂÖ•Â§±Ë¥•: ${error.message}`);
    }
  }
}

// ‰ΩøÁî®Á§∫‰æã
const openaiService = new AzureOpenAIService();

app.post('/chat', async (req, res) => {
  try {
    const messages = [
      { role: 'system', content: '‰Ω†ÊòØ‰∏Ä‰∏™ÊúâÂ∏ÆÂä©ÁöÑAIÂä©Êâã„ÄÇ' },
      { role: 'user', content: req.body.message }
    ];
    
    const response = await openaiService.chatCompletion(messages);
    res.json({ reply: response.message.content });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

## üìä Application Insights ÁõëÊéß

### 1. Â∫îÁî®ÁõëÊéß

```javascript
const appInsights = require('applicationinsights');

class ApplicationInsightsService {
  constructor() {
    appInsights.setup(process.env.APPLICATIONINSIGHTS_CONNECTION_STRING)
      .setAutoDependencyCorrelation(true)
      .setAutoCollectRequests(true)
      .setAutoCollectPerformance(true, true)
      .setAutoCollectExceptions(true)
      .setAutoCollectDependencies(true)
      .setAutoCollectConsole(true)
      .setUseDiskRetryCaching(true)
      .start();
      
    this.client = appInsights.defaultClient;
  }

  // ËÆ∞ÂΩïËá™ÂÆö‰πâ‰∫ã‰ª∂
  trackEvent(name, properties = {}, measurements = {}) {
    this.client.trackEvent({
      name,
      properties,
      measurements,
    });
  }

  // ËÆ∞ÂΩïÊåáÊ†á
  trackMetric(name, value, properties = {}) {
    this.client.trackMetric({
      name,
      value,
      properties,
    });
  }

  // ËÆ∞ÂΩïÂºÇÂ∏∏
  trackException(exception, properties = {}) {
    this.client.trackException({
      exception,
      properties,
    });
  }

  // ËÆ∞ÂΩï‰æùËµñË∞ÉÁî®
  trackDependency(dependencyTypeName, name, data, duration, success, properties = {}) {
    this.client.trackDependency({
      dependencyTypeName,
      name,
      data,
      duration,
      success,
      properties,
    });
  }

  // ËÆ∞ÂΩïËØ∑Ê±Ç
  trackRequest(name, url, duration, responseCode, success, properties = {}) {
    this.client.trackRequest({
      name,
      url,
      duration,
      responseCode,
      success,
      properties,
    });
  }
}

// ‰ΩøÁî®Á§∫‰æã
const insights = new ApplicationInsightsService();

// Express‰∏≠Èó¥‰ª∂
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    
    insights.trackRequest(
      `${req.method} ${req.path}`,
      req.url,
      duration,
      res.statusCode,
      res.statusCode < 400,
      {
        userAgent: req.get('User-Agent'),
        userId: req.user?.id,
      }
    );
  });
  
  next();
});

// ‰∏öÂä°‰∫ã‰ª∂ËøΩË∏™
app.post('/orders', async (req, res) => {
  try {
    const order = await createOrder(req.body);
    
    insights.trackEvent('OrderCreated', {
      orderId: order.id,
      userId: req.user.id,
      amount: order.total.toString(),
    }, {
      orderValue: order.total,
    });
    
    res.json(order);
  } catch (error) {
    insights.trackException(error, {
      operation: 'createOrder',
      userId: req.user?.id,
    });
    
    res.status(500).json({ error: error.message });
  }
});
```

## üîê Key Vault ÂØÜÈí•ÁÆ°ÁêÜ

### 1. ÂØÜÈí•ÂíåÊú∫ÂØÜÁÆ°ÁêÜ

```javascript
const { SecretClient } = require('@azure/keyvault-secrets');
const { DefaultAzureCredential } = require('@azure/identity');

class KeyVaultService {
  constructor() {
    const vaultUrl = `https://${process.env.KEY_VAULT_NAME}.vault.azure.net/`;
    this.client = new SecretClient(vaultUrl, new DefaultAzureCredential());
  }

  // Ëé∑ÂèñÂØÜÈí•
  async getSecret(secretName) {
    try {
      const secret = await this.client.getSecret(secretName);
      return secret.value;
    } catch (error) {
      throw new Error(`Ëé∑ÂèñÂØÜÈí•Â§±Ë¥•: ${error.message}`);
    }
  }

  // ËÆæÁΩÆÂØÜÈí•
  async setSecret(secretName, secretValue, options = {}) {
    try {
      const secret = await this.client.setSecret(secretName, secretValue, {
        expiresOn: options.expiresOn,
        notBefore: options.notBefore,
        enabled: options.enabled !== false,
        tags: options.tags,
      });
      
      return {
        name: secret.name,
        version: secret.properties.version,
        createdOn: secret.properties.createdOn,
      };
    } catch (error) {
      throw new Error(`ËÆæÁΩÆÂØÜÈí•Â§±Ë¥•: ${error.message}`);
    }
  }

  // Âà†Èô§ÂØÜÈí•
  async deleteSecret(secretName) {
    try {
      const deletePoller = await this.client.beginDeleteSecret(secretName);
      await deletePoller.pollUntilDone();
      return { success: true };
    } catch (error) {
      throw new Error(`Âà†Èô§ÂØÜÈí•Â§±Ë¥•: ${error.message}`);
    }
  }

  // ÂàóÂá∫ÂØÜÈí•
  async listSecrets() {
    try {
      const secrets = [];
      for await (const secretProperties of this.client.listPropertiesOfSecrets()) {
        secrets.push({
          name: secretProperties.name,
          version: secretProperties.version,
          enabled: secretProperties.enabled,
          createdOn: secretProperties.createdOn,
          updatedOn: secretProperties.updatedOn,
        });
      }
      return secrets;
    } catch (error) {
      throw new Error(`ÂàóÂá∫ÂØÜÈí•Â§±Ë¥•: ${error.message}`);
    }
  }
}

// ÈÖçÁΩÆÁÆ°ÁêÜÂô®
class ConfigManager {
  constructor() {
    this.keyVault = new KeyVaultService();
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5ÂàÜÈíüÁºìÂ≠ò
  }

  async getConfig(key) {
    const cacheKey = `config:${key}`;
    const cached = this.cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.value;
    }
    
    try {
      const value = await this.keyVault.getSecret(key);
      this.cache.set(cacheKey, {
        value,
        timestamp: Date.now(),
      });
      
      return value;
    } catch (error) {
      // Â¶ÇÊûúKey Vault‰∏çÂèØÁî®ÔºåËøîÂõûÁéØÂ¢ÉÂèòÈáè
      return process.env[key];
    }
  }
}

// ‰ΩøÁî®Á§∫‰æã
const configManager = new ConfigManager();

// Âú®Â∫îÁî®ÂêØÂä®Êó∂Ëé∑ÂèñÈÖçÁΩÆ
async function initializeApp() {
  try {
    const dbConnectionString = await configManager.getConfig('DATABASE_CONNECTION_STRING');
    const jwtSecret = await configManager.getConfig('JWT_SECRET');
    const apiKey = await configManager.getConfig('THIRD_PARTY_API_KEY');
    
    // ‰ΩøÁî®ÈÖçÁΩÆÂàùÂßãÂåñÊúçÂä°
    console.log('ÈÖçÁΩÆÂä†ËΩΩÊàêÂäü');
  } catch (error) {
    console.error('ÈÖçÁΩÆÂä†ËΩΩÂ§±Ë¥•:', error);
    process.exit(1);
  }
}

initializeApp();
```

## üöÄ ÂÆûÈôÖÂ∫îÁî®Á§∫‰æã

### ÂÆåÊï¥ÁöÑAzureÈõÜÊàêÂ∫îÁî®

```javascript
const express = require('express');
const multer = require('multer');

class AzureIntegratedService {
  constructor() {
    this.blobService = new AzureBlobService();
    this.cosmosService = new CosmosDBService();
    this.serviceBusService = new ServiceBusService();
    this.textAnalytics = new TextAnalyticsService();
    this.insights = new ApplicationInsightsService();
    this.configManager = new ConfigManager();
  }

  async processFileUpload(file, userId, metadata = {}) {
    const fileId = require('uuid').v4();
    const fileName = `${userId}/${fileId}-${file.originalname}`;
    
    try {
      // 1. ‰∏ä‰º†Âà∞Blob Storage
      const uploadResult = await this.blobService.uploadFile(fileName, file.buffer, {
        contentType: file.mimetype,
        metadata: { ...metadata, uploadedBy: userId },
      });
      
      // 2. ËÆ∞ÂΩïÂà∞Cosmos DB
      const document = await this.cosmosService.createDocument({
        id: fileId,
        userId,
        fileName: file.originalname,
        fileSize: file.size,
        mimeType: file.mimetype,
        blobName: fileName,
        status: 'uploaded',
        partitionKey: userId,
      });
      
      // 3. ÂèëÈÄÅÂ§ÑÁêÜÊ∂àÊÅØ
      await this.serviceBusService.sendToQueue('file-processing', {
        body: {
          fileId,
          blobName: fileName,
          mimeType: file.mimetype,
          userId,
        },
        applicationProperties: {
          fileType: file.mimetype,
        },
      });
      
      // 4. ËÆ∞ÂΩï‰∫ã‰ª∂
      this.insights.trackEvent('FileUploaded', {
        fileId,
        userId,
        fileSize: file.size.toString(),
        mimeType: file.mimetype,
      });
      
      return {
        fileId,
        status: 'uploaded',
        url: uploadResult.url,
      };
    } catch (error) {
      this.insights.trackException(error, {
        operation: 'fileUpload',
        userId,
      });
      
      throw error;
    }
  }

  async analyzeText(text, userId) {
    try {
      const documents = [{ id: '1', text, language: 'zh' }];
      
      const [sentiment, keyPhrases, entities] = await Promise.all([
        this.textAnalytics.analyzeSentiment(documents),
        this.textAnalytics.extractKeyPhrases(documents),
        this.textAnalytics.recognizeEntities(documents),
      ]);
      
      const analysisResult = {
        sentiment: sentiment[0],
        keyPhrases: keyPhrases[0],
        entities: entities[0],
        analyzedAt: new Date().toISOString(),
      };
      
      // ‰øùÂ≠òÂàÜÊûêÁªìÊûú
      await this.cosmosService.createDocument({
        id: require('uuid').v4(),
        userId,
        type: 'text-analysis',
        originalText: text,
        analysis: analysisResult,
        partitionKey: userId,
      });
      
      return analysisResult;
    } catch (error) {
      this.insights.trackException(error, {
        operation: 'textAnalysis',
        userId,
      });
      
      throw error;
    }
  }
}

// ExpressÂ∫îÁî®
const app = express();
const upload = multer({ storage: multer.memoryStorage() });
const azureService = new AzureIntegratedService();

app.use(express.json());

// Êñá‰ª∂‰∏ä‰º†
app.post('/upload', upload.single('file'), async (req, res) => {
  try {
    const result = await azureService.processFileUpload(
      req.file,
      req.user.id,
      { source: 'web-upload' }
    );
    
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÊñáÊú¨ÂàÜÊûê
app.post('/analyze-text', async (req, res) => {
  try {
    const result = await azureService.analyzeText(req.body.text, req.user.id);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ëé∑ÂèñÁî®Êà∑Êñá‰ª∂
app.get('/files', async (req, res) => {
  try {
    const files = await azureService.cosmosService.queryDocuments({
      query: 'SELECT * FROM c WHERE c.userId = @userId AND c.type != @excludeType',
      parameters: [
        { name: '@userId', value: req.user.id },
        { name: '@excludeType', value: 'text-analysis' }
      ],
    });
    
    res.json(files);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(3000, () => {
  console.log('AzureÈõÜÊàêÂ∫îÁî®ÂêØÂä®Âú®Á´ØÂè£ 3000');
});
```

## üìö ÊúÄ‰Ω≥ÂÆûË∑µÊÄªÁªì

1. **Ë∫´‰ªΩÈ™åËØÅ**Ôºö‰ΩøÁî®DefaultAzureCredentialËøõË°åÁªü‰∏ÄË∫´‰ªΩÈ™åËØÅ
2. **ÈîôËØØÂ§ÑÁêÜ**ÔºöÂÆûÁé∞ÈáçËØïÊú∫Âà∂Âíå‰ºòÈõÖÈôçÁ∫ß
3. **ÁõëÊéß**Ôºö‰ΩøÁî®Application InsightsËøõË°åÂÖ®Èù¢ÁõëÊéß
4. **ÈÖçÁΩÆÁÆ°ÁêÜ**Ôºö‰ΩøÁî®Key VaultÁÆ°ÁêÜÊïèÊÑüÈÖçÁΩÆ
5. **ËµÑÊ∫êÁÆ°ÁêÜ**ÔºöÊ≠£Á°ÆÂÖ≥Èó≠ÂÆ¢Êà∑Á´ØËøûÊé•ÂíåËµÑÊ∫ê
6. **ÊÄßËÉΩ‰ºòÂåñ**Ôºö‰ΩøÁî®ËøûÊé•Ê±†ÂíåÊâπÈáèÊìç‰Ωú
7. **ÂÆâÂÖ®ÊÄß**ÔºöÈÅµÂæ™ÊúÄÂ∞èÊùÉÈôêÂéüÂàôÈÖçÁΩÆRBAC

ÈÄöËøáÊéåÊè°Ëøô‰∫õAzureÊúçÂä°ÈõÜÊàêÊäÄÊúØÔºåÊÇ®Â∞ÜËÉΩÂ§üÊûÑÂª∫Âº∫Â§ß„ÄÅÂèØÊâ©Â±ïÁöÑ‰∫ëÂéüÁîüNode.jsÂ∫îÁî®Á®ãÂ∫è„ÄÇ
