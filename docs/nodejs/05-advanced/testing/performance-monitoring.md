# æ€§èƒ½ç›‘æ§

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- æŒæ¡æ€§èƒ½ç›‘æ§çš„åŸºæœ¬æ¦‚å¿µå’Œæ–¹æ³•
- å­¦ä¼šä½¿ç”¨å„ç§æ€§èƒ½ç›‘æ§å·¥å…·
- ç†è§£æ€§èƒ½æŒ‡æ ‡å’Œä¼˜åŒ–ç­–ç•¥
- æŒæ¡å®æ—¶æ€§èƒ½ç›‘æ§å’Œå‘Šè­¦
- å­¦ä¼šæ€§èƒ½æ•°æ®åˆ†æå’ŒæŠ¥å‘Š

## ğŸ“š ç›®å½•

1. [æ€§èƒ½ç›‘æ§åŸºç¡€](#æ€§èƒ½ç›‘æ§åŸºç¡€)
2. [æ€§èƒ½æŒ‡æ ‡](#æ€§èƒ½æŒ‡æ ‡)
3. [ç›‘æ§å·¥å…·](#ç›‘æ§å·¥å…·)
4. [Node.jsæ€§èƒ½ç›‘æ§](#nodejsæ€§èƒ½ç›‘æ§)
5. [å‰ç«¯æ€§èƒ½ç›‘æ§](#å‰ç«¯æ€§èƒ½ç›‘æ§)
6. [æ•°æ®åº“æ€§èƒ½ç›‘æ§](#æ•°æ®åº“æ€§èƒ½ç›‘æ§)
7. [å®æ—¶ç›‘æ§å’Œå‘Šè­¦](#å®æ—¶ç›‘æ§å’Œå‘Šè­¦)
8. [æ€§èƒ½åˆ†æå’Œä¼˜åŒ–](#æ€§èƒ½åˆ†æå’Œä¼˜åŒ–)
9. [ç›‘æ§æœ€ä½³å®è·µ](#ç›‘æ§æœ€ä½³å®è·µ)

## æ€§èƒ½ç›‘æ§åŸºç¡€

### ä»€ä¹ˆæ˜¯æ€§èƒ½ç›‘æ§

æ€§èƒ½ç›‘æ§æ˜¯æŒç»­è§‚å¯Ÿã€æµ‹é‡å’Œåˆ†æåº”ç”¨ç¨‹åºæ€§èƒ½çš„è¿‡ç¨‹ï¼ŒåŒ…æ‹¬ï¼š

- **å®æ—¶ç›‘æ§**ï¼šæŒç»­è§‚å¯Ÿç³»ç»ŸçŠ¶æ€
- **æ€§èƒ½æŒ‡æ ‡**ï¼šé‡åŒ–æ€§èƒ½æ•°æ®
- **è¶‹åŠ¿åˆ†æ**ï¼šè¯†åˆ«æ€§èƒ½å˜åŒ–æ¨¡å¼
- **å‘Šè­¦æœºåˆ¶**ï¼šåŠæ—¶å‘ç°é—®é¢˜
- **ä¼˜åŒ–å»ºè®®**ï¼šæä¾›æ”¹è¿›æ–¹å‘

### ç›‘æ§æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åº”ç”¨ç¨‹åº      â”‚    â”‚   ç›‘æ§ä»£ç†      â”‚    â”‚   ç›‘æ§å¹³å°      â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ - æ€§èƒ½æ•°æ®      â”‚â”€â”€â”€â–ºâ”‚ - æ•°æ®æ”¶é›†      â”‚â”€â”€â”€â–ºâ”‚ - æ•°æ®å­˜å‚¨      â”‚
â”‚ - ä¸šåŠ¡æŒ‡æ ‡      â”‚    â”‚ - æ•°æ®é¢„å¤„ç†    â”‚    â”‚ - æ•°æ®åˆ†æ      â”‚
â”‚ - é”™è¯¯æ—¥å¿—      â”‚    â”‚ - æ•°æ®å‘é€      â”‚    â”‚ - å¯è§†åŒ–å±•ç¤º    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## æ€§èƒ½æŒ‡æ ‡

### ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡

```javascript
// CPUä½¿ç”¨ç‡ç›‘æ§
const os = require('os')

function getCPUUsage() {
  const cpus = os.cpus()
  let totalIdle = 0
  let totalTick = 0
  
  cpus.forEach(cpu => {
    for (let type in cpu.times) {
      totalTick += cpu.times[type]
    }
    totalIdle += cpu.times.idle
  })
  
  return {
    idle: totalIdle / cpus.length,
    total: totalTick / cpus.length,
    usage: 100 - ~~(100 * totalIdle / totalTick)
  }
}

// å†…å­˜ä½¿ç”¨ç›‘æ§
function getMemoryUsage() {
  const total = os.totalmem()
  const free = os.freemem()
  const used = total - free
  
  return {
    total: total,
    used: used,
    free: free,
    usage: (used / total) * 100
  }
}

// ç£ç›˜ä½¿ç”¨ç›‘æ§
const fs = require('fs')

function getDiskUsage(path = '/') {
  const stats = fs.statSync(path)
  return {
    total: stats.size,
    used: stats.size - stats.free,
    free: stats.free,
    usage: ((stats.size - stats.free) / stats.size) * 100
  }
}
```

### åº”ç”¨æ€§èƒ½æŒ‡æ ‡

```javascript
// HTTPè¯·æ±‚æ€§èƒ½ç›‘æ§
const express = require('express')
const app = express()

// è¯·æ±‚æ—¶é—´ç›‘æ§ä¸­é—´ä»¶
app.use((req, res, next) => {
  const start = Date.now()
  
  res.on('finish', () => {
    const duration = Date.now() - start
    console.log(`${req.method} ${req.url} - ${duration}ms`)
    
    // è®°å½•åˆ°ç›‘æ§ç³»ç»Ÿ
    recordMetric('http_request_duration', duration, {
      method: req.method,
      url: req.url,
      status: res.statusCode
    })
  })
  
  next()
})

// æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½ç›‘æ§
function monitorDatabaseQuery(query, params) {
  const start = Date.now()
  
  return query(params).then(result => {
    const duration = Date.now() - start
    console.log(`Database query - ${duration}ms`)
    
    recordMetric('database_query_duration', duration, {
      query: query.name || 'unknown',
      params: JSON.stringify(params)
    })
    
    return result
  })
}
```

### ä¸šåŠ¡æ€§èƒ½æŒ‡æ ‡

```javascript
// ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§
class BusinessMetrics {
  constructor() {
    this.metrics = new Map()
  }
  
  // ç”¨æˆ·æ³¨å†ŒæˆåŠŸç‡
  recordUserRegistration(success) {
    this.incrementMetric('user_registration_total', { success })
    if (success) {
      this.incrementMetric('user_registration_success')
    } else {
      this.incrementMetric('user_registration_failure')
    }
  }
  
  // è®¢å•å¤„ç†æ—¶é—´
  recordOrderProcessing(orderId, duration) {
    this.recordMetric('order_processing_duration', duration, {
      order_id: orderId
    })
  }
  
  // æ”¯ä»˜æˆåŠŸç‡
  recordPayment(success, amount) {
    this.incrementMetric('payment_total', { success })
    this.recordMetric('payment_amount', amount, { success })
  }
  
  incrementMetric(name, labels = {}) {
    const key = `${name}_${JSON.stringify(labels)}`
    this.metrics.set(key, (this.metrics.get(key) || 0) + 1)
  }
  
  recordMetric(name, value, labels = {}) {
    const key = `${name}_${JSON.stringify(labels)}`
    const values = this.metrics.get(key) || []
    values.push({ value, timestamp: Date.now() })
    this.metrics.set(key, values)
  }
}
```

## ç›‘æ§å·¥å…·

### Prometheus + Grafana

```javascript
// Prometheuså®¢æˆ·ç«¯é…ç½®
const client = require('prom-client')

// åˆ›å»ºæŒ‡æ ‡
const httpRequestDuration = new client.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
})

const activeConnections = new client.Gauge({
  name: 'active_connections',
  help: 'Number of active connections'
})

const totalRequests = new client.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code']
})

// Expressä¸­é—´ä»¶
app.use((req, res, next) => {
  const start = Date.now()
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000
    const route = req.route ? req.route.path : req.path
    
    httpRequestDuration
      .labels(req.method, route, res.statusCode)
      .observe(duration)
    
    totalRequests
      .labels(req.method, route, res.statusCode)
      .inc()
  })
  
  next()
})

// å¯åŠ¨æŒ‡æ ‡æœåŠ¡å™¨
app.get('/metrics', (req, res) => {
  res.set('Content-Type', client.register.contentType)
  res.end(client.register.metrics())
})
```

### New Relicç›‘æ§

```javascript
// New Relicé…ç½®
const newrelic = require('newrelic')

// è‡ªå®šä¹‰æŒ‡æ ‡
newrelic.recordMetric('Custom/UserRegistrations', 1)
newrelic.recordMetric('Custom/OrderValue', 99.99)

// è‡ªå®šä¹‰äº‹ä»¶
newrelic.recordCustomEvent('UserAction', {
  action: 'login',
  userId: '12345',
  timestamp: Date.now()
})

// æ•°æ®åº“æŸ¥è¯¢ç›‘æ§
const mysql = require('mysql2/promise')

const connection = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'mydb'
})

// åŒ…è£…æ•°æ®åº“æŸ¥è¯¢
async function query(sql, params) {
  return newrelic.startSegment('Database/MySQL', true, async () => {
    const [rows] = await connection.execute(sql, params)
    return rows
  })
}
```

### DataDogç›‘æ§

```javascript
// DataDogé…ç½®
const tracer = require('dd-trace').init({
  service: 'my-node-app',
  env: 'production',
  version: '1.0.0'
})

// è‡ªå®šä¹‰span
const span = tracer.startSpan('custom-operation')
span.setTag('user.id', '12345')
span.setTag('operation.type', 'data-processing')

try {
  // æ‰§è¡Œæ“ä½œ
  await processData()
  span.setTag('success', true)
} catch (error) {
  span.setTag('error', true)
  span.setTag('error.message', error.message)
  throw error
} finally {
  span.finish()
}

// HTTPè¯·æ±‚ç›‘æ§
const express = require('express')
const app = express()

app.use(tracer.express())

app.get('/api/users', async (req, res) => {
  const span = tracer.startSpan('get-users')
  
  try {
    const users = await getUsers()
    res.json(users)
  } finally {
    span.finish()
  }
})
```

## Node.jsæ€§èƒ½ç›‘æ§

### è¿›ç¨‹ç›‘æ§

```javascript
// è¿›ç¨‹æ€§èƒ½ç›‘æ§
const process = require('process')

class ProcessMonitor {
  constructor() {
    this.startTime = Date.now()
    this.metrics = {
      cpuUsage: 0,
      memoryUsage: 0,
      eventLoopLag: 0,
      activeHandles: 0,
      activeRequests: 0
    }
  }
  
  // CPUä½¿ç”¨ç‡ç›‘æ§
  monitorCPUUsage() {
    setInterval(() => {
      const usage = process.cpuUsage()
      this.metrics.cpuUsage = usage.user + usage.system
    }, 1000)
  }
  
  // å†…å­˜ä½¿ç”¨ç›‘æ§
  monitorMemoryUsage() {
    setInterval(() => {
      const usage = process.memoryUsage()
      this.metrics.memoryUsage = {
        rss: usage.rss,
        heapTotal: usage.heapTotal,
        heapUsed: usage.heapUsed,
        external: usage.external
      }
    }, 1000)
  }
  
  // äº‹ä»¶å¾ªç¯å»¶è¿Ÿç›‘æ§
  monitorEventLoopLag() {
    const start = process.hrtime()
    
    setImmediate(() => {
      const delta = process.hrtime(start)
      const lag = delta[0] * 1000 + delta[1] / 1000000
      this.metrics.eventLoopLag = lag
    })
  }
  
  // å¥æŸ„å’Œè¯·æ±‚ç›‘æ§
  monitorHandlesAndRequests() {
    setInterval(() => {
      this.metrics.activeHandles = process._getActiveHandles().length
      this.metrics.activeRequests = process._getActiveRequests().length
    }, 1000)
  }
  
  start() {
    this.monitorCPUUsage()
    this.monitorMemoryUsage()
    this.monitorEventLoopLag()
    this.monitorHandlesAndRequests()
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      uptime: Date.now() - this.startTime,
      pid: process.pid,
      version: process.version
    }
  }
}

const monitor = new ProcessMonitor()
monitor.start()
```

### å†…å­˜æ³„æ¼ç›‘æ§

```javascript
// å†…å­˜æ³„æ¼æ£€æµ‹
const v8 = require('v8')

class MemoryLeakDetector {
  constructor() {
    this.baseline = null
    this.threshold = 50 * 1024 * 1024 // 50MB
    this.checkInterval = 30000 // 30ç§’
  }
  
  start() {
    // è®¾ç½®åŸºçº¿
    this.baseline = this.getMemoryUsage()
    
    setInterval(() => {
      this.checkMemoryLeak()
    }, this.checkInterval)
  }
  
  getMemoryUsage() {
    const usage = process.memoryUsage()
    const heapStats = v8.getHeapStatistics()
    
    return {
      rss: usage.rss,
      heapTotal: usage.heapTotal,
      heapUsed: usage.heapUsed,
      external: usage.external,
      heapSizeLimit: heapStats.heap_size_limit,
      totalHeapSize: heapStats.total_heap_size,
      usedHeapSize: heapStats.used_heap_size
    }
  }
  
  checkMemoryLeak() {
    const current = this.getMemoryUsage()
    
    if (this.baseline) {
      const heapGrowth = current.heapUsed - this.baseline.heapUsed
      
      if (heapGrowth > this.threshold) {
        console.warn('æ½œåœ¨å†…å­˜æ³„æ¼æ£€æµ‹:', {
          heapGrowth: heapGrowth,
          threshold: this.threshold,
          current: current,
          baseline: this.baseline
        })
        
        // è§¦å‘åƒåœ¾å›æ”¶
        if (global.gc) {
          global.gc()
        }
        
        // æ›´æ–°åŸºçº¿
        this.baseline = current
      }
    }
  }
  
  // å¼ºåˆ¶åƒåœ¾å›æ”¶
  forceGC() {
    if (global.gc) {
      global.gc()
      return true
    }
    return false
  }
}

const leakDetector = new MemoryLeakDetector()
leakDetector.start()
```

### é”™è¯¯ç›‘æ§

```javascript
// é”™è¯¯ç›‘æ§å’ŒæŠ¥å‘Š
class ErrorMonitor {
  constructor() {
    this.errorCounts = new Map()
    this.errorHistory = []
    this.maxHistorySize = 1000
  }
  
  // å…¨å±€é”™è¯¯å¤„ç†
  setupGlobalErrorHandlers() {
    process.on('uncaughtException', (error) => {
      this.recordError('uncaughtException', error)
      this.shutdown()
    })
    
    process.on('unhandledRejection', (reason, promise) => {
      this.recordError('unhandledRejection', reason)
    })
    
    process.on('warning', (warning) => {
      this.recordError('warning', warning)
    })
  }
  
  recordError(type, error) {
    const errorInfo = {
      type: type,
      message: error.message || error,
      stack: error.stack,
      timestamp: Date.now(),
      pid: process.pid
    }
    
    // è®°å½•é”™è¯¯å†å²
    this.errorHistory.push(errorInfo)
    if (this.errorHistory.length > this.maxHistorySize) {
      this.errorHistory.shift()
    }
    
    // ç»Ÿè®¡é”™è¯¯æ¬¡æ•°
    const key = `${type}:${errorInfo.message}`
    this.errorCounts.set(key, (this.errorCounts.get(key) || 0) + 1)
    
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    this.sendToMonitoring(errorInfo)
  }
  
  sendToMonitoring(errorInfo) {
    // å‘é€åˆ°å¤–éƒ¨ç›‘æ§ç³»ç»Ÿ
    console.error('Error recorded:', errorInfo)
    
    // å¯ä»¥é›†æˆSentryã€Bugsnagç­‰
    // Sentry.captureException(error)
  }
  
  getErrorStats() {
    return {
      totalErrors: this.errorHistory.length,
      errorCounts: Object.fromEntries(this.errorCounts),
      recentErrors: this.errorHistory.slice(-10)
    }
  }
  
  shutdown() {
    console.log('Shutting down due to uncaught exception')
    process.exit(1)
  }
}

const errorMonitor = new ErrorMonitor()
errorMonitor.setupGlobalErrorHandlers()
```

## å‰ç«¯æ€§èƒ½ç›‘æ§

### é¡µé¢æ€§èƒ½ç›‘æ§

```javascript
// å‰ç«¯æ€§èƒ½ç›‘æ§
class FrontendPerformanceMonitor {
  constructor() {
    this.metrics = {}
    this.init()
  }
  
  init() {
    // é¡µé¢åŠ è½½æ€§èƒ½
    this.measurePageLoad()
    
    // èµ„æºåŠ è½½æ€§èƒ½
    this.measureResourceTiming()
    
    // ç”¨æˆ·äº¤äº’æ€§èƒ½
    this.measureUserInteraction()
    
    // é”™è¯¯ç›‘æ§
    this.measureErrors()
  }
  
  measurePageLoad() {
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0]
      
      this.metrics.pageLoad = {
        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
        totalTime: navigation.loadEventEnd - navigation.fetchStart,
        firstPaint: this.getFirstPaint(),
        firstContentfulPaint: this.getFirstContentfulPaint()
      }
      
      this.sendMetrics('pageLoad', this.metrics.pageLoad)
    })
  }
  
  measureResourceTiming() {
    const resources = performance.getEntriesByType('resource')
    
    resources.forEach(resource => {
      const timing = {
        name: resource.name,
        duration: resource.duration,
        size: resource.transferSize,
        type: resource.initiatorType
      }
      
      this.sendMetrics('resourceTiming', timing)
    })
  }
  
  measureUserInteraction() {
    // ç‚¹å‡»å“åº”æ—¶é—´
    document.addEventListener('click', (event) => {
      const start = performance.now()
      
      requestAnimationFrame(() => {
        const end = performance.now()
        const responseTime = end - start
        
        this.sendMetrics('clickResponse', {
          responseTime: responseTime,
          target: event.target.tagName,
          className: event.target.className
        })
      })
    })
    
    // æ»šåŠ¨æ€§èƒ½
    let scrollStart = 0
    document.addEventListener('scroll', () => {
      if (scrollStart === 0) {
        scrollStart = performance.now()
      }
      
      requestAnimationFrame(() => {
        const scrollEnd = performance.now()
        const scrollDuration = scrollEnd - scrollStart
        
        if (scrollDuration > 16) { // è¶…è¿‡ä¸€å¸§çš„æ—¶é—´
          this.sendMetrics('scrollPerformance', {
            duration: scrollDuration,
            threshold: 16
          })
        }
        
        scrollStart = 0
      })
    })
  }
  
  measureErrors() {
    window.addEventListener('error', (event) => {
      this.sendMetrics('javascriptError', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error ? event.error.stack : null
      })
    })
    
    window.addEventListener('unhandledrejection', (event) => {
      this.sendMetrics('unhandledRejection', {
        reason: event.reason,
        promise: event.promise
      })
    })
  }
  
  getFirstPaint() {
    const paintEntries = performance.getEntriesByType('paint')
    const firstPaint = paintEntries.find(entry => entry.name === 'first-paint')
    return firstPaint ? firstPaint.startTime : null
  }
  
  getFirstContentfulPaint() {
    const paintEntries = performance.getEntriesByType('paint')
    const firstContentfulPaint = paintEntries.find(entry => entry.name === 'first-contentful-paint')
    return firstContentfulPaint ? firstContentfulPaint.startTime : null
  }
  
  sendMetrics(type, data) {
    // å‘é€åˆ°åç«¯ç›‘æ§ç³»ç»Ÿ
    fetch('/api/metrics', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        type: type,
        data: data,
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent
      })
    }).catch(error => {
      console.error('Failed to send metrics:', error)
    })
  }
}

// åˆå§‹åŒ–å‰ç«¯æ€§èƒ½ç›‘æ§
const performanceMonitor = new FrontendPerformanceMonitor()
```

## æ•°æ®åº“æ€§èƒ½ç›‘æ§

### MySQLæ€§èƒ½ç›‘æ§

```javascript
// MySQLæ€§èƒ½ç›‘æ§
const mysql = require('mysql2/promise')

class MySQLPerformanceMonitor {
  constructor(connection) {
    this.connection = connection
    this.queryStats = new Map()
    this.slowQueryThreshold = 1000 // 1ç§’
  }
  
  // ç›‘æ§æŸ¥è¯¢æ€§èƒ½
  async executeQuery(sql, params = []) {
    const start = Date.now()
    
    try {
      const [rows] = await this.connection.execute(sql, params)
      const duration = Date.now() - start
      
      this.recordQueryStats(sql, duration, true)
      
      if (duration > this.slowQueryThreshold) {
        this.recordSlowQuery(sql, duration, params)
      }
      
      return rows
    } catch (error) {
      const duration = Date.now() - start
      this.recordQueryStats(sql, duration, false)
      throw error
    }
  }
  
  recordQueryStats(sql, duration, success) {
    const queryType = this.getQueryType(sql)
    const key = `${queryType}_${success ? 'success' : 'error'}`
    
    const stats = this.queryStats.get(key) || {
      count: 0,
      totalDuration: 0,
      avgDuration: 0,
      minDuration: Infinity,
      maxDuration: 0
    }
    
    stats.count++
    stats.totalDuration += duration
    stats.avgDuration = stats.totalDuration / stats.count
    stats.minDuration = Math.min(stats.minDuration, duration)
    stats.maxDuration = Math.max(stats.maxDuration, duration)
    
    this.queryStats.set(key, stats)
  }
  
  recordSlowQuery(sql, duration, params) {
    console.warn('Slow query detected:', {
      sql: sql,
      duration: duration,
      params: params,
      timestamp: new Date().toISOString()
    })
    
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    this.sendToMonitoring('slowQuery', {
      sql: sql,
      duration: duration,
      params: params
    })
  }
  
  getQueryType(sql) {
    const trimmed = sql.trim().toLowerCase()
    if (trimmed.startsWith('select')) return 'SELECT'
    if (trimmed.startsWith('insert')) return 'INSERT'
    if (trimmed.startsWith('update')) return 'UPDATE'
    if (trimmed.startsWith('delete')) return 'DELETE'
    return 'OTHER'
  }
  
  // è·å–æ•°æ®åº“çŠ¶æ€
  async getDatabaseStatus() {
    const queries = [
      'SHOW STATUS LIKE "Threads_connected"',
      'SHOW STATUS LIKE "Threads_running"',
      'SHOW STATUS LIKE "Questions"',
      'SHOW STATUS LIKE "Uptime"',
      'SHOW VARIABLES LIKE "max_connections"'
    ]
    
    const results = {}
    
    for (const query of queries) {
      const [rows] = await this.connection.execute(query)
      const key = rows[0].Variable_name
      const value = rows[0].Value
      results[key] = parseInt(value)
    }
    
    return results
  }
  
  sendToMonitoring(type, data) {
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    console.log(`Monitoring: ${type}`, data)
  }
  
  getStats() {
    return {
      queryStats: Object.fromEntries(this.queryStats),
      timestamp: Date.now()
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const connection = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'mydb'
})

const monitor = new MySQLPerformanceMonitor(connection)
```

## å®æ—¶ç›‘æ§å’Œå‘Šè­¦

### å‘Šè­¦ç³»ç»Ÿ

```javascript
// å‘Šè­¦ç³»ç»Ÿ
class AlertSystem {
  constructor() {
    this.rules = new Map()
    this.alerts = []
    this.notificationChannels = []
  }
  
  // æ·»åŠ å‘Šè­¦è§„åˆ™
  addRule(name, condition, threshold, severity = 'warning') {
    this.rules.set(name, {
      condition: condition,
      threshold: threshold,
      severity: severity,
      lastTriggered: null,
      cooldown: 300000 // 5åˆ†é’Ÿå†·å´æœŸ
    })
  }
  
  // æ£€æŸ¥å‘Šè­¦æ¡ä»¶
  checkAlerts(metrics) {
    for (const [ruleName, rule] of this.rules) {
      if (this.shouldCheckRule(rule)) {
        const triggered = this.evaluateCondition(rule.condition, metrics, rule.threshold)
        
        if (triggered) {
          this.triggerAlert(ruleName, rule, metrics)
        }
      }
    }
  }
  
  shouldCheckRule(rule) {
    const now = Date.now()
    return !rule.lastTriggered || (now - rule.lastTriggered) > rule.cooldown
  }
  
  evaluateCondition(condition, metrics, threshold) {
    switch (condition) {
      case 'cpu_usage_high':
        return metrics.cpuUsage > threshold
      case 'memory_usage_high':
        return metrics.memoryUsage.usage > threshold
      case 'response_time_slow':
        return metrics.avgResponseTime > threshold
      case 'error_rate_high':
        return metrics.errorRate > threshold
      case 'disk_usage_high':
        return metrics.diskUsage > threshold
      default:
        return false
    }
  }
  
  triggerAlert(ruleName, rule, metrics) {
    const alert = {
      id: Date.now(),
      ruleName: ruleName,
      severity: rule.severity,
      message: this.generateAlertMessage(ruleName, rule, metrics),
      metrics: metrics,
      timestamp: new Date().toISOString(),
      resolved: false
    }
    
    this.alerts.push(alert)
    rule.lastTriggered = Date.now()
    
    // å‘é€é€šçŸ¥
    this.sendNotification(alert)
    
    console.warn('Alert triggered:', alert)
  }
  
  generateAlertMessage(ruleName, rule, metrics) {
    const messages = {
      cpu_usage_high: `CPUä½¿ç”¨ç‡è¿‡é«˜: ${metrics.cpuUsage}% (é˜ˆå€¼: ${rule.threshold}%)`,
      memory_usage_high: `å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: ${metrics.memoryUsage.usage}% (é˜ˆå€¼: ${rule.threshold}%)`,
      response_time_slow: `å“åº”æ—¶é—´è¿‡æ…¢: ${metrics.avgResponseTime}ms (é˜ˆå€¼: ${rule.threshold}ms)`,
      error_rate_high: `é”™è¯¯ç‡è¿‡é«˜: ${metrics.errorRate}% (é˜ˆå€¼: ${rule.threshold}%)`,
      disk_usage_high: `ç£ç›˜ä½¿ç”¨ç‡è¿‡é«˜: ${metrics.diskUsage}% (é˜ˆå€¼: ${rule.threshold}%)`
    }
    
    return messages[ruleName] || `å‘Šè­¦è§¦å‘: ${ruleName}`
  }
  
  sendNotification(alert) {
    this.notificationChannels.forEach(channel => {
      channel.send(alert)
    })
  }
  
  // æ·»åŠ é€šçŸ¥æ¸ é“
  addNotificationChannel(channel) {
    this.notificationChannels.push(channel)
  }
  
  // è§£å†³å‘Šè­¦
  resolveAlert(alertId) {
    const alert = this.alerts.find(a => a.id === alertId)
    if (alert) {
      alert.resolved = true
      alert.resolvedAt = new Date().toISOString()
    }
  }
  
  getActiveAlerts() {
    return this.alerts.filter(alert => !alert.resolved)
  }
}

// é€šçŸ¥æ¸ é“å®ç°
class EmailNotificationChannel {
  constructor(emailConfig) {
    this.config = emailConfig
  }
  
  send(alert) {
    // å‘é€é‚®ä»¶é€šçŸ¥
    console.log(`Sending email alert: ${alert.message}`)
  }
}

class SlackNotificationChannel {
  constructor(webhookUrl) {
    this.webhookUrl = webhookUrl
  }
  
  send(alert) {
    // å‘é€Slacké€šçŸ¥
    console.log(`Sending Slack alert: ${alert.message}`)
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const alertSystem = new AlertSystem()

// æ·»åŠ å‘Šè­¦è§„åˆ™
alertSystem.addRule('cpu_high', 'cpu_usage_high', 80, 'critical')
alertSystem.addRule('memory_high', 'memory_usage_high', 90, 'warning')
alertSystem.addRule('response_slow', 'response_time_slow', 2000, 'warning')

// æ·»åŠ é€šçŸ¥æ¸ é“
alertSystem.addNotificationChannel(new EmailNotificationChannel({}))
alertSystem.addNotificationChannel(new SlackNotificationChannel(''))
```

## æ€§èƒ½åˆ†æå’Œä¼˜åŒ–

### æ€§èƒ½åˆ†æå·¥å…·

```javascript
// æ€§èƒ½åˆ†æå™¨
class PerformanceProfiler {
  constructor() {
    this.profiles = new Map()
    this.activeProfiles = new Map()
  }
  
  // å¼€å§‹æ€§èƒ½åˆ†æ
  startProfile(name) {
    const profile = {
      name: name,
      startTime: Date.now(),
      startMemory: process.memoryUsage(),
      startCPU: process.cpuUsage()
    }
    
    this.activeProfiles.set(name, profile)
    return profile
  }
  
  // ç»“æŸæ€§èƒ½åˆ†æ
  endProfile(name) {
    const profile = this.activeProfiles.get(name)
    if (!profile) {
      throw new Error(`Profile ${name} not found`)
    }
    
    const endTime = Date.now()
    const endMemory = process.memoryUsage()
    const endCPU = process.cpuUsage(profile.startCPU)
    
    const result = {
      name: name,
      duration: endTime - profile.startTime,
      memoryDelta: {
        rss: endMemory.rss - profile.startMemory.rss,
        heapUsed: endMemory.heapUsed - profile.startMemory.heapUsed,
        heapTotal: endMemory.heapTotal - profile.startMemory.heapTotal,
        external: endMemory.external - profile.startMemory.external
      },
      cpuDelta: {
        user: endCPU.user,
        system: endCPU.system
      },
      timestamp: new Date().toISOString()
    }
    
    this.profiles.set(name, result)
    this.activeProfiles.delete(name)
    
    return result
  }
  
  // åˆ†ææ€§èƒ½ç“¶é¢ˆ
  analyzeBottlenecks() {
    const analysis = {
      slowestProfiles: [],
      memoryIntensiveProfiles: [],
      cpuIntensiveProfiles: []
    }
    
    for (const [name, profile] of this.profiles) {
      // æœ€æ…¢çš„æ“ä½œ
      if (profile.duration > 1000) {
        analysis.slowestProfiles.push({
          name: name,
          duration: profile.duration
        })
      }
      
      // å†…å­˜å¯†é›†å‹æ“ä½œ
      if (profile.memoryDelta.heapUsed > 10 * 1024 * 1024) { // 10MB
        analysis.memoryIntensiveProfiles.push({
          name: name,
          memoryUsed: profile.memoryDelta.heapUsed
        })
      }
      
      // CPUå¯†é›†å‹æ“ä½œ
      if (profile.cpuDelta.user > 1000000) { // 1ç§’CPUæ—¶é—´
        analysis.cpuIntensiveProfiles.push({
          name: name,
          cpuTime: profile.cpuDelta.user
        })
      }
    }
    
    // æ’åº
    analysis.slowestProfiles.sort((a, b) => b.duration - a.duration)
    analysis.memoryIntensiveProfiles.sort((a, b) => b.memoryUsed - a.memoryUsed)
    analysis.cpuIntensiveProfiles.sort((a, b) => b.cpuTime - a.cpuTime)
    
    return analysis
  }
  
  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  generateReport() {
    const analysis = this.analyzeBottlenecks()
    
    return {
      summary: {
        totalProfiles: this.profiles.size,
        slowestOperation: analysis.slowestProfiles[0],
        mostMemoryIntensive: analysis.memoryIntensiveProfiles[0],
        mostCPUIntensive: analysis.cpuIntensiveProfiles[0]
      },
      details: analysis,
      recommendations: this.generateRecommendations(analysis)
    }
  }
  
  generateRecommendations(analysis) {
    const recommendations = []
    
    if (analysis.slowestProfiles.length > 0) {
      recommendations.push({
        type: 'performance',
        message: 'å‘ç°æ…¢æ“ä½œï¼Œå»ºè®®ä¼˜åŒ–ç®—æ³•æˆ–æ·»åŠ ç¼“å­˜',
        profiles: analysis.slowestProfiles.slice(0, 3)
      })
    }
    
    if (analysis.memoryIntensiveProfiles.length > 0) {
      recommendations.push({
        type: 'memory',
        message: 'å‘ç°å†…å­˜å¯†é›†å‹æ“ä½œï¼Œå»ºè®®ä¼˜åŒ–å†…å­˜ä½¿ç”¨',
        profiles: analysis.memoryIntensiveProfiles.slice(0, 3)
      })
    }
    
    if (analysis.cpuIntensiveProfiles.length > 0) {
      recommendations.push({
        type: 'cpu',
        message: 'å‘ç°CPUå¯†é›†å‹æ“ä½œï¼Œå»ºè®®è€ƒè™‘å¼‚æ­¥å¤„ç†æˆ–è´Ÿè½½å‡è¡¡',
        profiles: analysis.cpuIntensiveProfiles.slice(0, 3)
      })
    }
    
    return recommendations
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const profiler = new PerformanceProfiler()

// åˆ†æAPIç«¯ç‚¹æ€§èƒ½
app.get('/api/users', async (req, res) => {
  const profile = profiler.startProfile('getUsers')
  
  try {
    const users = await getUsers()
    res.json(users)
  } finally {
    profiler.endProfile('getUsers')
  }
})

// å®šæœŸç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
setInterval(() => {
  const report = profiler.generateReport()
  console.log('Performance Report:', JSON.stringify(report, null, 2))
}, 300000) // æ¯5åˆ†é’Ÿ
```

## ç›‘æ§æœ€ä½³å®è·µ

### ç›‘æ§ç­–ç•¥

```javascript
// ç›‘æ§é…ç½®ç®¡ç†
class MonitoringConfig {
  constructor() {
    this.config = {
      // æ€§èƒ½é˜ˆå€¼
      thresholds: {
        cpuUsage: 80,
        memoryUsage: 90,
        diskUsage: 85,
        responseTime: 2000,
        errorRate: 5
      },
      
      // ç›‘æ§é—´éš”
      intervals: {
        systemMetrics: 10000,    // 10ç§’
        applicationMetrics: 5000, // 5ç§’
        databaseMetrics: 15000,   // 15ç§’
        alertCheck: 30000        // 30ç§’
      },
      
      // æ•°æ®ä¿ç•™
      retention: {
        metrics: 7 * 24 * 60 * 60 * 1000,  // 7å¤©
        logs: 30 * 24 * 60 * 60 * 1000,    // 30å¤©
        alerts: 90 * 24 * 60 * 60 * 1000   // 90å¤©
      }
    }
  }
  
  getThreshold(metric) {
    return this.config.thresholds[metric]
  }
  
  getInterval(type) {
    return this.config.intervals[type]
  }
  
  getRetention(type) {
    return this.config.retention[type]
  }
  
  updateThreshold(metric, value) {
    this.config.thresholds[metric] = value
  }
}

// ç›‘æ§æ•°æ®ç®¡ç†
class MonitoringDataManager {
  constructor() {
    this.metrics = new Map()
    this.logs = []
    this.alerts = []
  }
  
  // å­˜å‚¨æŒ‡æ ‡
  storeMetric(name, value, labels = {}, timestamp = Date.now()) {
    const key = `${name}_${JSON.stringify(labels)}`
    const data = this.metrics.get(key) || []
    
    data.push({
      value: value,
      timestamp: timestamp,
      labels: labels
    })
    
    // é™åˆ¶æ•°æ®å¤§å°
    if (data.length > 10000) {
      data.splice(0, 1000) // åˆ é™¤æœ€æ—§çš„1000æ¡
    }
    
    this.metrics.set(key, data)
  }
  
  // è·å–æŒ‡æ ‡
  getMetric(name, labels = {}, timeRange = null) {
    const key = `${name}_${JSON.stringify(labels)}`
    let data = this.metrics.get(key) || []
    
    if (timeRange) {
      const startTime = Date.now() - timeRange
      data = data.filter(item => item.timestamp >= startTime)
    }
    
    return data
  }
  
  // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
  calculateStats(data) {
    if (data.length === 0) return null
    
    const values = data.map(item => item.value)
    const sum = values.reduce((a, b) => a + b, 0)
    
    return {
      count: values.length,
      sum: sum,
      avg: sum / values.length,
      min: Math.min(...values),
      max: Math.max(...values),
      p50: this.percentile(values, 50),
      p95: this.percentile(values, 95),
      p99: this.percentile(values, 99)
    }
  }
  
  percentile(values, p) {
    const sorted = values.sort((a, b) => a - b)
    const index = Math.ceil((p / 100) * sorted.length) - 1
    return sorted[index]
  }
  
  // æ¸…ç†è¿‡æœŸæ•°æ®
  cleanup(retentionTime) {
    const cutoffTime = Date.now() - retentionTime
    
    // æ¸…ç†æŒ‡æ ‡
    for (const [key, data] of this.metrics) {
      const filtered = data.filter(item => item.timestamp >= cutoffTime)
      if (filtered.length === 0) {
        this.metrics.delete(key)
      } else {
        this.metrics.set(key, filtered)
      }
    }
    
    // æ¸…ç†æ—¥å¿—
    this.logs = this.logs.filter(log => log.timestamp >= cutoffTime)
    
    // æ¸…ç†å‘Šè­¦
    this.alerts = this.alerts.filter(alert => alert.timestamp >= cutoffTime)
  }
}

// ç›‘æ§æœåŠ¡
class MonitoringService {
  constructor() {
    this.config = new MonitoringConfig()
    this.dataManager = new MonitoringDataManager()
    this.alertSystem = new AlertSystem()
    this.isRunning = false
  }
  
  start() {
    if (this.isRunning) return
    
    this.isRunning = true
    
    // å¯åŠ¨å„ç§ç›‘æ§
    this.startSystemMonitoring()
    this.startApplicationMonitoring()
    this.startDatabaseMonitoring()
    this.startAlertChecking()
    this.startDataCleanup()
    
    console.log('Monitoring service started')
  }
  
  stop() {
    this.isRunning = false
    console.log('Monitoring service stopped')
  }
  
  startSystemMonitoring() {
    setInterval(() => {
      if (!this.isRunning) return
      
      const cpuUsage = getCPUUsage()
      const memoryUsage = getMemoryUsage()
      const diskUsage = getDiskUsage()
      
      this.dataManager.storeMetric('cpu_usage', cpuUsage.usage)
      this.dataManager.storeMetric('memory_usage', memoryUsage.usage)
      this.dataManager.storeMetric('disk_usage', diskUsage.usage)
      
      // æ£€æŸ¥å‘Šè­¦
      this.alertSystem.checkAlerts({
        cpuUsage: cpuUsage.usage,
        memoryUsage: memoryUsage,
        diskUsage: diskUsage.usage
      })
    }, this.config.getInterval('systemMetrics'))
  }
  
  startApplicationMonitoring() {
    setInterval(() => {
      if (!this.isRunning) return
      
      // åº”ç”¨æŒ‡æ ‡ç›‘æ§
      const processMonitor = new ProcessMonitor()
      const metrics = processMonitor.getMetrics()
      
      this.dataManager.storeMetric('event_loop_lag', metrics.eventLoopLag)
      this.dataManager.storeMetric('active_handles', metrics.activeHandles)
      this.dataManager.storeMetric('active_requests', metrics.activeRequests)
    }, this.config.getInterval('applicationMetrics'))
  }
  
  startDatabaseMonitoring() {
    setInterval(() => {
      if (!this.isRunning) return
      
      // æ•°æ®åº“ç›‘æ§
      // å®ç°æ•°æ®åº“ç›‘æ§é€»è¾‘
    }, this.config.getInterval('databaseMetrics'))
  }
  
  startAlertChecking() {
    setInterval(() => {
      if (!this.isRunning) return
      
      // å®šæœŸæ£€æŸ¥å‘Šè­¦
      // å®ç°å‘Šè­¦æ£€æŸ¥é€»è¾‘
    }, this.config.getInterval('alertCheck'))
  }
  
  startDataCleanup() {
    setInterval(() => {
      if (!this.isRunning) return
      
      // æ¸…ç†è¿‡æœŸæ•°æ®
      this.dataManager.cleanup(this.config.getRetention('metrics'))
    }, 24 * 60 * 60 * 1000) // æ¯å¤©æ¸…ç†ä¸€æ¬¡
  }
  
  // è·å–ç›‘æ§ä»ªè¡¨æ¿æ•°æ®
  getDashboardData() {
    const now = Date.now()
    const oneHour = 60 * 60 * 1000
    
    return {
      systemMetrics: {
        cpu: this.dataManager.getMetric('cpu_usage', {}, oneHour),
        memory: this.dataManager.getMetric('memory_usage', {}, oneHour),
        disk: this.dataManager.getMetric('disk_usage', {}, oneHour)
      },
      applicationMetrics: {
        eventLoopLag: this.dataManager.getMetric('event_loop_lag', {}, oneHour),
        activeHandles: this.dataManager.getMetric('active_handles', {}, oneHour)
      },
      alerts: this.alertSystem.getActiveAlerts(),
      timestamp: now
    }
  }
}

// å¯åŠ¨ç›‘æ§æœåŠ¡
const monitoringService = new MonitoringService()
monitoringService.start()
```

## ğŸ¯ å®è·µé¡¹ç›®

### é¡¹ç›®1ï¼šå®Œæ•´çš„ç›‘æ§ç³»ç»Ÿ

åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„Node.jsåº”ç”¨ç›‘æ§ç³»ç»Ÿï¼š

```javascript
// ç›‘æ§ç³»ç»Ÿä¸»æ–‡ä»¶
const express = require('express')
const app = express()

// ç›‘æ§ä¸­é—´ä»¶
app.use((req, res, next) => {
  const start = Date.now()
  
  res.on('finish', () => {
    const duration = Date.now() - start
    monitoringService.recordHTTPRequest({
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: duration
    })
  })
  
  next()
})

// ç›‘æ§APIç«¯ç‚¹
app.get('/api/monitoring/dashboard', (req, res) => {
  const data = monitoringService.getDashboardData()
  res.json(data)
})

app.get('/api/monitoring/metrics/:name', (req, res) => {
  const { name } = req.params
  const { labels, timeRange } = req.query
  
  const data = monitoringService.getMetric(name, labels, timeRange)
  res.json(data)
})

app.get('/api/monitoring/alerts', (req, res) => {
  const alerts = monitoringService.getActiveAlerts()
  res.json(alerts)
})

// å¯åŠ¨æœåŠ¡å™¨
app.listen(3000, () => {
  console.log('Monitoring service running on port 3000')
})
```

### é¡¹ç›®2ï¼šæ€§èƒ½ä¼˜åŒ–å»ºè®®ç³»ç»Ÿ

```javascript
// æ€§èƒ½ä¼˜åŒ–å»ºè®®ç³»ç»Ÿ
class PerformanceOptimizer {
  constructor() {
    this.rules = [
      {
        name: 'high_cpu_usage',
        condition: (metrics) => metrics.cpuUsage > 80,
        suggestion: 'è€ƒè™‘ä¼˜åŒ–CPUå¯†é›†å‹æ“ä½œæˆ–å¢åŠ æœåŠ¡å™¨èµ„æº'
      },
      {
        name: 'memory_leak',
        condition: (metrics) => metrics.memoryGrowth > 100 * 1024 * 1024,
        suggestion: 'æ£€æŸ¥å†…å­˜æ³„æ¼ï¼Œä¼˜åŒ–å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç®¡ç†'
      },
      {
        name: 'slow_database_queries',
        condition: (metrics) => metrics.avgQueryTime > 1000,
        suggestion: 'ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢ï¼Œæ·»åŠ ç´¢å¼•æˆ–ä½¿ç”¨ç¼“å­˜'
      }
    ]
  }
  
  analyze(metrics) {
    const suggestions = []
    
    this.rules.forEach(rule => {
      if (rule.condition(metrics)) {
        suggestions.push({
          rule: rule.name,
          suggestion: rule.suggestion,
          severity: this.getSeverity(rule.name),
          timestamp: new Date().toISOString()
        })
      }
    })
    
    return suggestions
  }
  
  getSeverity(ruleName) {
    const severityMap = {
      'high_cpu_usage': 'high',
      'memory_leak': 'critical',
      'slow_database_queries': 'medium'
    }
    
    return severityMap[ruleName] || 'low'
  }
}
```

## ğŸ“ æ€»ç»“

é€šè¿‡æœ¬æŒ‡å—ï¼Œæ‚¨å·²ç»æŒæ¡äº†ï¼š

1. **æ€§èƒ½ç›‘æ§åŸºç¡€**ï¼šç›‘æ§æ¦‚å¿µã€æ¶æ„å’ŒæŒ‡æ ‡
2. **ç›‘æ§å·¥å…·**ï¼šPrometheusã€Grafanaã€New Relicã€DataDog
3. **Node.jsç›‘æ§**ï¼šè¿›ç¨‹ã€å†…å­˜ã€é”™è¯¯ç›‘æ§
4. **å‰ç«¯ç›‘æ§**ï¼šé¡µé¢æ€§èƒ½ã€ç”¨æˆ·äº¤äº’ç›‘æ§
5. **æ•°æ®åº“ç›‘æ§**ï¼šæŸ¥è¯¢æ€§èƒ½ã€è¿æ¥çŠ¶æ€ç›‘æ§
6. **å‘Šè­¦ç³»ç»Ÿ**ï¼šå®æ—¶ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶
7. **æ€§èƒ½åˆ†æ**ï¼šç“¶é¢ˆè¯†åˆ«å’Œä¼˜åŒ–å»ºè®®
8. **æœ€ä½³å®è·µ**ï¼šç›‘æ§ç­–ç•¥å’Œæ•°æ®ç®¡ç†

### ä¸‹ä¸€æ­¥å­¦ä¹ 

- [è´Ÿè½½æµ‹è¯•](./load-testing.md) - ç³»ç»Ÿè´Ÿè½½æµ‹è¯•æ–¹æ³•
- [å‹åŠ›æµ‹è¯•](./stress-testing.md) - ç³»ç»Ÿå‹åŠ›æµ‹è¯•
- [DevOpsä¸CI/CD](../devops/README.md) - æŒç»­é›†æˆå’Œéƒ¨ç½²

ç»§ç»­å­¦ä¹ ï¼ŒæŒæ¡æ€§èƒ½ç›‘æ§æŠ€èƒ½ï¼ğŸš€
